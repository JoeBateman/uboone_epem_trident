//********************************************************************************
//  TridentEventGenerator
//
//  version 1.0 by Wolfgang Altmannshofer (01/18/2019)
//  version 2.0 modification by Joseph Bateman (01/15/2025)
//
//********************************************************************************

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <cstdio>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <iterator>
#include <vector>
#include "TFile.h"
#include "TH1.h"
#include "TH2.h"
#include "TTree.h"
#include "TKey.h"

using namespace std;
using std::fstream;



//*****************************************************************
// global constants and input parameters
//*****************************************************************
double pi = 3.1415926535897;
double Twopi = 2*pi;
//*****************************************************************
double GF = 0.0000116637; // Fermi constant
double aem = 1/137.036; // em coupling
double sW2 = 0.23119; // sin^2 of the weak mixing angle
//*****************************************************************
double me = 0.000511; // electron mass
double me2 = me*me;
double mmu = 0.105658; // muon mass
double mmu2 = mmu*mmu;
double mtau = 1.778; // tau mass
double mtau2 = mtau*mtau;

//*****************************************************************
// Define masses of various nuclei
//*****************************************************************
double MCarbon = 12.01*0.9315;
double MNitrogen = 14.01*0.9315;
double MOxygen = 16.0*0.9315;
double MSilicon = 28.09*0.9315;
double MArgon = 39.95*0.9315;
double MIron = 55.85*0.9315;
//*****************************************************************
double Mproton = 0.938272;
double Mneutron = 0.939565;
//*****************************************************************
// magnetic moments of proton and neutron
double mup = 2.7928;
double mun = -1.913;

//*****************************************************************
// form factor parameters for proton and neutron
//*****************************************************************
double bpM1 = 12.31;
double bpM2 = 25.57;
double bpM3 = 30.61;
double apM1 = 1.09;
double bpE1 = 11.12;
double bpE2 = 15.16;
double bpE3 = 21.25;
double apE1 = -0.19;
double ffA = 1.68;
double ffB = 3.63;
double bnM1 = 21.3;
double bnM2 = 77;
double bnM3 = 238;
double anM1 = 8.28;

//*****************************************************************
// nuclear parameters, effective couplings, lepton masses ...
//*****************************************************************
double A, Z, M, M2;
double GV, GA, GVSM, GASM;
double m3, m4;
double InterpolationList[192][2]; // array used for interpolation of form factor grid

//*****************************************************************
// variables for reading the neutrino flux distribution file
//*****************************************************************
vector<double> distribution_list;
vector<double> Enumin_list;
vector<double> Enumax_list;
vector<double> probability_list;

int length_probability_list;
int bin;


//*****************************************************************
// flags
//*****************************************************************
int zeroweight;
int anti;
int readerror = 0;
int flagkinematics = 0;
int errorcounter = 0;
int eventcounter = 0;
int reweightcounter = 0;


//*****************************************************************
// variables for data output
//*****************************************************************
double *data;
int PDG1, PDG2, PDG3, PDG4;


//*****************************************************************
// Variables entered in the users interface
//*****************************************************************
int process;
string material;
string energy_type;
string model;
string command;
string filename_in, filename_out;
double Enu, GP, MZP;
double GVtot, GAtot; 
int Nevents;


//*****************************************************************
// Variables used for random point generation
//*****************************************************************
double eps1, g;
double x1max, x1min;
double x0, x1, x2, x3, x4, x5, x6, x7, x8;
double u1max, u2max, u3max, u4max, u5max, u6max, u7max;
double u1min, u2min, u3min, u4min, u5min, u6min, u7min;
double u1, u2, u3, u4, u5, u6, u7;
double D3max, D3min, D3, D32;
double D4max, D4min, D4, D42, D3D4;
double yplus, yminus;
double phi3, phi4, P2, P5, WC, WC2, WCqc, WB, WB2, qc;
double P0C, PC, q0C, qC, eps1C, eps4C, p4C, P4; 
double cos4, cosPq, sin4, sinPq, cosP1q, cosPp1, sinP1q, sinPp1, cosPhi, sinPhi;
double p1P, q2, qp1, qp3, qp4, p1p3, p1p4, p3P, p4P, Pq, qP, p2P, qp2, p1p2, p2p3, p2p4, p3p4;


//*****************************************************************
// Variables used to define events
//*****************************************************************
double Theta, sintheta, costheta;
double Eq, qx, qy, qz;
double Enuin, pnuinx, pnuiny, pnuinz;
double Enuout, pnuoutx, pnuoutz, pnuouty; 
double Elminus, plminusx, plminusy, plminusz; 
double Elplus, plplusz, plplusy, plplusx;
double Eprime, Pprimez, Pprimey, Pprimex;
double event[5][4];


//*****************************************************************
// Variables for weight and crosssection calculations
//*****************************************************************
double J, PLP, Laa, deltaSigma, weight, maxweight, averageweight;
double crosssectionresult;
double deltacrosssectionresult;


//*****************************************************************
// functions
//*****************************************************************
void SetTridentProcess();
void SetNuclearParameters();
void GenerateEvent();
void GenerateEvents();
void GenerateRandomPoint();
void DetermineWeight();
void FindMaxWeight();
void ComputeCrossSection();
void ReadDistribution();
void LoadFluxFromROOT(string, int);
void WriteEventFile(string);
void WriteXsecTempFile(string);
double SquaredMatrixElementPLP(double, double);
double SquaredMatrixElementPLPanti(double, double);
double SquaredMatrixElementL(double, double);
double SquaredMatrixElementLanti(double, double);
double Interpolation(double, int);
double InverseInterpolation(double, int);
double GMp(double);
double GEp(double);
double GMn(double);
double GEn(double);
double GD(double);
double Pauli(double);

//*****************************************************************
// Define the form factor grids
//*****************************************************************

// proton:
double InterpolationListProton[192][2] = {
    0.0000000, 0.35491136115644123, 
    0.0000008, 0.3549105611578789, 
    0.0000064, 0.354904961248448, 
    0.0000216, 0.35488976220442014, 
    0.0000512, 0.35486016704427764, 
    0.0001000, 0.35481138361426373,
    0.0001728, 0.3547386282040495, 
    0.0002744, 0.35463713018644377,
    0.0004096, 0.354502137671319, 
    0.0005832, 0.35432892415924266,
    0.0008000, 0.354112796174763,
    0.0010648, 0.35384910185290785, 
    0.0013824, 0.35353324044529516,
    0.0017576, 0.3531606727043793, 
    0.0021952, 0.3527269320958761,
    0.0027000, 0.3522276367804185,
    0.0032768, 0.35165850229612317, 
    0.0039304, 0.35101535486414515,
    0.0046656, 0.3502941452296272, 
    0.0054872, 0.3494909629408831,
    0.0064000, 0.34860205096039654, 
    0.0074088, 0.34762382049246365, 
    0.0085184, 0.3465528659042747,
    0.0097336, 0.3453859796101249, 
    0.0110592, 0.3441201667824999,
    0.0125000, 0.34275265974916347,
    0.0140608, 0.34128093193232345, 
    0.0157464, 0.33970271118458883,
    0.0175616, 0.3380159923769428, 
    0.0195112, 0.33621904909642053,
    0.0216000, 0.3343104443157112,
    0.0238328, 0.3322890399034934, 
    0.0262144, 0.3301540048529919,
    0.0287496, 0.3279048221169234, 
    0.0314432, 0.32554129394959636,
    0.0343000, 0.32306354567126333, 
    0.0373248, 0.3204720277857366,
    0.0405224, 0.3177675163994695, 
    0.0438976, 0.3149511119085545, 
    0.0474552, 0.3120242359390426, 
    0.0512000, 0.30898862654533726, 
    0.0551368, 0.30584633169080305,
    0.0592704, 0.30259970105380773,
    0.0636056, 0.2992513762208386, 
    0.0681472, 0.2958042793457659,
    0.0729000, 0.2922616003704634,
    0.0778688, 0.2886267829165608, 
    0.0830584, 0.2849035089708541,
    0.0884736, 0.28109568249765743, 
    0.0941192, 0.2772074121199755,
    0.1000000, 0.2732429930177614, 
    0.11, 0.2666951614074109,
    0.14, 0.24840133526455527, 
    0.19, 0.22178857640981323,
    0.26, 0.19098912247923858, 
    0.35, 0.15962869252507347,
    0.46, 0.13024933309001746, 
    0.59, 0.10428094962952672,
    0.74, 0.08227970948006394, 
    0.91, 0.06422082262731268, 
    1.10, 0.04974830786952152, 
    1.31, 0.03835610242089349,
    1.54, 0.029505234450581147, 
    1.79, 0.022690988438595943,
    2.06, 0.017474886047186926, 
    2.35, 0.013494234625941527,
    2.66, 0.010458974337703127, 
    2.99, 0.008142512303684053,
    3.34, 0.006370670362625037, 
    3.71, 0.005010990252110424,
    4.10, 0.003963411060786835, 
    4.51, 0.003152618337299878,
    4.94, 0.002521998298962822, 
    5.39, 0.0020289764666886188,
    5.86, 0.0016414809789114591, 
    6.35, 0.001335286662387736,
    6.86, 0.0010920328847828268, 
    7.39, 0.0008977491405030563,
    7.94, 0.0007417596109981341, 
    8.51, 0.0006158689830646376, 
    9.10, 0.0005137563813479302, 
    9.71, 0.0004305231363241781,
   10.34, 0.00036235431460257165, 
   10.99, 0.00030626450394207155,
   11.66, 0.00025990614314796247, 
   12.35, 0.00022142441600551347,
   13.06, 0.00018934692793303611, 
   13.79, 0.00016249946050335968,
   14.54, 0.00013994135407047648, 
   15.31, 0.00012091572423854551,
   16.10, 0.00010481093591060915, 
   16.91, 0.00009113065720394685,
   17.74, 0.00007947048045865464,
   18.59, 0.00006949959130119641, 
   19.46, 0.000060946334658935325,
   20.35, 0.00005358680184011661, 
   21.26, 0.00004723576945609173,
   22.19, 0.00004173947675715388, 
   23.14, 0.000036969845867152436,
   24.11, 0.00003281983900173365,
   25.10, 0.000029199715110520404, 
   26.11, 0.00002603400073834784, 
   27.14, 0.000023259030157665856, 
   28.19, 0.00002082094089903848, 
   29.26, 0.000018674034885542623, 
   30.35, 0.000016779434105188533, 
   31.46, 0.000015103974376243558, 
   32.59, 0.000013619292216019746,
   33.74, 0.000012301068831559084,
   34.91, 0.000011128402358591577,
   36.10, 0.000010083285103148487, 
   37.31, 0.000009150167011431608,
   38.54, 0.000008315590157387473, 
   39.79, 0.0000075678818872726794,
   41.06, 0.0000068968965464820074,
   42.35, 0.000006293797553303156,
   43.66, 0.000005750873068744655,
   44.99, 0.000005261379713168353,
   46.34, 0.000004819409755855068,
   47.71, 0.000004419777997645781,
   49.10, 0.000004057925214937379,
   50.51, 0.0000037298355637928938,
   51.94, 0.00000343196577824915,
   53.39, 0.0000031611843550554845,
   54.86, 0.000002914719212475154,
   56.35, 0.000002690112555018635,
   57.86, 0.000002485181878399028,
   59.39, 0.0000022979862171571595,
   60.94, 0.000002126796877416817,
   62.51, 0.0000019700720140708097,
   64.10, 0.000001826434509413918,
   65.71, 0.0000016946526921377817,
   67.34, 0.0000015736235043820997,
   68.99, 0.0000014623577824269814,
   70.66, 0.0000013599673654235834,
   72.35, 0.0000012656537878059758,
   74.06, 0.000001178698345943241,
   75.79, 0.0000010984533592047114,
   77.54, 0.0000010243344707744435,
   79.31, 0.0000009558138549708845,
   81.10, 0.0000008924142160932148,
   82.91, 0.0000008337034794185852,
   84.74, 0.0000007792900883250944,
   86.59, 0.000000728818832957915,
   88.46, 0.0000006819671456791537,
   90.35, 0.0000006384418069884009,
   92.26, 0.000000597976012874841,
   94.19, 0.000000560326760835576,
   96.14, 0.0000005252725172141305,
   98.11, 0.0000004926111332011915,
  100.10, 0.00000046215798090108713,
  102.11, 0.00000043374428439082025,
  104.14, 0.00000040721562376003257,
  106.19, 0.00000038243059278234117,
  108.26, 0.0000003592595931891489,
  110.35, 0.00000033758375053979994,
  112.46, 0.0000003172939384493653,
  114.59, 0.00000029828989948067866,
  116.74, 0.000000280479452360349,
  118.91, 0.0000002637777763646586,
  121.10, 0.0000002481067647623743,
  123.31, 0.00000023339444011636185,
  125.54, 0.00000021957442505075086,
  127.79, 0.0000002065854627992727,
  130.06, 0.00000019437098247545037,
  132.35, 0.00000018287870455704816,
  134.66, 0.00000017206028256474816,
  136.99, 0.00000016187097734630985,
  139.34, 0.00000015226936075939175,
  141.71, 0.00000014321704588476764,
  144.10, 0.0000001346784412020875,
  146.51, 0.00000012662052642712278,
  148.94, 0.00000011901264794681052,
  151.39, 0.00000011182633199929873,
  153.86, 0.00000010503511393453219,
  156.35, 0.00000009861438205843786,
  158.86, 0.00000009254123471348657,
  161.39, 0.00000008679434938207754,
  163.94, 0.00000008135386271870999,
  166.51, 0.0000000762012605238495,
  169.10, 0.00000007131927676818101,
  171.71, 0.00000006669180086179382,
  174.34, 0.000000062303792439867,
  176.99, 0.00000005814120300557658,
  179.66, 0.000000054190903833089075,
  182.35, 0.00000005044061958938736,
  185.06, 0.000000046878867183972935,
  187.79, 0.00000004349489940078969,
  190.54, 0.000000040278652907550395,
  193.31, 0.00000003722070027448465,
  196.10, 0.00000003431220566778151,
  198.91, 0.00000003154488391304329};
  
// neutron:
double InterpolationListNeutron[201][2] = {
    0.0000000, 0.0720946188333362,
    0.0000008, 0.07209461883300457, 
    0.0000064, 0.07209461881211196,
    0.0000216, 0.07209461859159688, 
    0.0000512, 0.07209461747528562,
    0.0001000, 0.07209461365403758,
    0.0001728, 0.07209460337361277,
    0.0002744, 0.07209457986930903,
    0.0004096, 0.07209453207229638,
    0.0005832, 0.07209444309489246,
    0.0008000, 0.07209428850474926,
    0.0010648, 0.07209403440101467,
    0.0013824, 0.07209363530893939,
    0.0017576, 0.0720930319130511,
    0.0021952, 0.07209214865283214,
    0.0027000, 0.07209089120871333,
    0.0032768, 0.07208914391003014,
    0.0039304, 0.07208676710025529,
    0.0046656, 0.07208359449819321,
    0.0054872, 0.07207943059677242,
    0.0064000, 0.07207404814345997,
    0.0074088, 0.07206718574803646,
    0.0085184, 0.07205854566438583,
    0.0097336, 0.07204779179298652,
    0.0110592, 0.07203454794986502,
    0.0125000, 0.07201839644584679,
    0.0140608, 0.07199887701700891,
    0.0157464, 0.07197548614332289,
    0.0175616, 0.0719476767876454,
    0.0195112, 0.07191485858156205,
    0.0216000, 0.07187639847825097,
    0.0238328, 0.0718316218856647,
    0.0262144, 0.07177981428611738,
    0.0287496, 0.07172022334100321,
    0.0314432, 0.071652061472063,
    0.0343000, 0.07157450890355936,
    0.0373248, 0.07148671714310062,
    0.0405224, 0.07138781287283376,
    0.0438976, 0.07127690221744423,
    0.0474552, 0.07115307535095396,
    0.0512000, 0.07101541140076677,
    0.0551368, 0.07086298360479236,
    0.0592704, 0.07069486467577646,
    0.0636056, 0.07051013232612581,
    0.0681472, 0.070307874906463,
    0.0729000, 0.07008719711177287,
    0.0778688, 0.06984722571019503,
    0.0830584, 0.06958711525113553,
    0.0884736, 0.06930605371129464,
    0.0941192, 0.06900326803930354,
    0.10, 0.06867802956181829,
    0.11, 0.06810402385073701,
    0.14, 0.06625288809980635,
    0.19, 0.06288613130801046,
    0.26, 0.05793565801214362,
    0.35, 0.051655544939513284,
    0.46, 0.04457300135775631,
    0.59, 0.03731849277371218,
    0.74, 0.030448271381746227,
    0.91, 0.024337193189640848,
    1.10, 0.019159578051501796,
    1.31, 0.014930094076850545,
    1.54, 0.011564829485860455,
    1.79, 0.008935113603828242,
    2.06, 0.006903849402813075,
    2.35, 0.005345233214529056,
    2.66, 0.004152802307577919,
    2.99, 0.00324073210328937,
    3.34, 0.00254189445643889,
    3.71, 0.002004761786342395,
    4.10, 0.0015902247670692442,
    4.51, 0.0012687820051796221,
    4.94, 0.0010182382048326659,
    5.39, 0.0008218974614455215,
    5.86, 0.0006671808020414981,
    6.35, 0.0005445844272407458,
    6.86, 0.00044690164717254346,
    7.39, 0.00036864446114903286,
    7.94, 0.00030561430627283793,
    8.51, 0.0002545834196002937,
    9.10, 0.000213057909134175,
    9.71, 0.00017910110482346334,
   10.34, 0.00015120140338229377,
   10.99, 0.00012817301335308142,
   11.66, 0.00010908109307704792,
   12.35, 0.00009318503426868153,
   13.06, 0.000079895294944851,
   13.79, 0.00006874039110464183,
   14.54, 0.00005934153779451261,
   15.31, 0.00005139307557508415,
   16.10, 0.00004464729232258394,
   16.91, 0.00003890259941837013,
   17.74, 0.00003399427948568824,
   18.59, 0.000029787214383093835,
   19.46, 0.000026170144891604155,
   20.35, 0.00002305112032093306,
   21.26, 0.000020353876494073623,
   22.19, 0.00001801494110713793,
   23.14, 0.000015981311330932448,
   24.11, 0.000014208583422647155,
   25.10, 0.000012659440783443162,
   26.11, 0.000011302427357413937,
   27.14, 0.000010110949028179201,
   28.19, 0.000009062457858933151,
   29.26, 0.000008137783486292764,
   30.35, 0.00000732058335524217,
   31.46, 0.000006596889253967501,
   32.59, 0.000005954732139473548,
   33.74, 0.000005383830816565086,
   34.91, 0.0000048753328575111156,
   36.10, 0.000004421598391400509,
   37.31, 0.000004016019177184351,
   38.54, 0.0000036528668003840855,
   39.79, 0.000003327164976315365,
   41.06, 0.0000030345818614865708,
   42.35, 0.0000027713390157864394,
   43.66, 0.000002534134257380694,
   44.99, 0.0000023200761383885316, 
   46.34, 0.0000021266281648934395,
   47.71, 0.0000019515612074630438,
   49.10, 0.0000017929128122479915,
   50.51, 0.0000016489523391616736,
   51.94, 0.0000015181510316070565,
   53.39, 0.0000013991562689207062,
   54.86, 0.0000012907693739371015,
   56.35, 0.0000011919264485023435,
   57.86, 0.0000011016817931525679,
   59.39, 0.0000010191935365693687,
   60.94, 0.0000009437111583093684,
   62.51, 0.0000008745646366930724, 
   64.10, 0.0000008111549942765959,
   65.71, 0.0000007529460473585724, 
   67.34, 0.00000069945719460519,
   68.99, 0.0000006502571040059414, 
   70.66, 0.0000006049581777542484,
   72.35, 0.00000056321169189359, 
   74.06, 0.000000524703522191577,
   75.79, 0.0000004891503801237266, 
   77.54, 0.0000004562964934163899,
   79.31, 0.0000004259106746063125, 
   81.10, 0.0000003977837287661527,
   82.91, 0.00000037172615812442045, 
   84.74, 0.00000034756612694504663,
   86.59, 0.0000003251476548689864, 
   88.46, 0.00000030432901107797747,
   90.35, 0.00000028498128521982295, 
   92.26, 0.00000026698711412056984, 
   94.19, 0.00000025023954597369607,
   96.14, 0.00000023464102600078012, 
   98.11, 0.00000022010248957374332,
  100.10, 0.00000020654255051945514, 
  102.11, 0.0000001938867738304418,
  104.14, 0.0000001820670233127379, 
  106.19, 0.00000017102087583976101,
  108.26, 0.00000016069109487396806,
  110.35, 0.0000001510251567842943, 
  112.46, 0.00000014197482424496555,
  114.59, 0.00000013349576166427018, 
  116.74, 0.00000012554718817291174,
  118.91, 0.00000011809156421136155, 
  121.10, 0.00000011109430820345826,
  123.31, 0.00000010452354019734886, 
  125.54, 0.0000000983498497016306, 
  127.79, 0.00000009254608525021281, 
  130.06, 0.00000008708716349913605,
  132.35, 0.0000000819498958968487, 
  134.66, 0.00000007711283118014253,
  136.99, 0.00000007255611213447197, 
  139.34, 0.00000006826134522266695,
  141.71, 0.00000006421148183267084, 
  144.10, 0.00000006039071002512605,
  146.51, 0.000000056784355777324556, 
  148.94, 0.000000053378792823047076,
  151.39, 0.00000005016136027938411, 
  153.86, 0.000000047120287333460946, 
  156.35, 0.0000000442446243348178,
  158.86, 0.000000041524179704323284,
  161.39, 0.00000003894946212868072, 
  163.94, 0.000000036511627561637094,
  166.51, 0.0000000342024305996054, 
  169.10, 0.000000032014179841171,
  171.71, 0.00000002993969687740508, 
  174.34, 0.000000027972278593523464,
  176.99, 0.00000002610566249262784, 
  179.66, 0.000000024333994779415518,
  182.35, 0.000000022651800966171, 
  185.06, 0.000000021053958785348548,
  187.79, 0.000000019535673212876094, 
  190.54, 0.000000018092453424185884,
  193.31, 0.00000001672009152110996, 
  196.10, 0.000000015414642882348045,
  198.91, 0.000000014172408003384575};

// Argon:
double InterpolationListAr[192][2] = {
    0.0000000, 0.009064890762226647, 
    0.0001000, 0.008965401072506351,
    0.0001331, 0.008932694087135882,
    0.0001728, 0.008893611611748469, 
    0.0002197, 0.008847645724290096,
    0.0002744, 0.00879431388121322, 
    0.0003375, 0.008733162932309824, 
    0.0004096, 0.008663773297402519,
    0.0004913, 0.00858576325723903, 
    0.0005832, 0.008498793305342443,
    0.0006859, 0.00840257032568025,
    0.0008000, 0.008296852618316395,
    0.0009261, 0.0081814529259797,
    0.0010648, 0.008056243171420325,
    0.0012167, 0.007921157955073449, 
    0.0013824, 0.007776197871460146,
    0.0015625, 0.007621432415664943,
    0.0017576, 0.007457002372110704, 
    0.0019683, 0.007283121620431031,
    0.0021952, 0.0071000785299381395, 
    0.0024389, 0.006908235355444478,
    0.0027000, 0.006708029371054425,
    0.0029791, 0.006499971152490813,
    0.0032768, 0.006284641824980943, 
    0.0035937, 0.006062690816296752,
    0.0039304, 0.005834832486356098, 
    0.0042875, 0.005601837860161134,
    0.0046656, 0.005364535901426475, 
    0.0050653, 0.0051238001797039075,
    0.0054872, 0.004880544250267348,
    0.0059319, 0.004635714018722241,
    0.0064000, 0.004390278498576905,
    0.0068921, 0.0041452197378874355, 
    0.0074088, 0.0039015246473167123, 
    0.0079507, 0.003660173257992295,
    0.0085184, 0.003422130689685586,
    0.0091125, 0.0031883334503064764,
    0.0097336, 0.002959684597634732, 
    0.0103823, 0.0027370393189212277, 
    0.0110592, 0.0025211984759095844,
    0.0117649, 0.002312899112675782, 
    0.0125000, 0.0021128071280098132, 
    0.0132651, 0.0019215104918164734,
    0.0140608, 0.0017395136255078034, 
    0.0148877, 0.0015672329632314796, 
    0.0157464, 0.0014049937939444315, 
    0.0166375, 0.0012530284989814287, 
    0.0175616, 0.001111475864099673,
    0.0185193, 0.0009803823266709996, 
    0.0195112, 0.0008597039556965142,
    0.0205379, 0.0007493102979937443,
    0.0216000, 0.0006489889176932642,
    0.0226981, 0.0005584515237006674, 
    0.0238328, 0.0004773407062572494, 
    0.0250047, 0.0004052377830504229, 
    0.0262144, 0.0003416711762835676, 
    0.0274625, 0.0002861253901084263, 
    0.0287496, 0.00023805024321828437, 
    0.0300763, 0.00019687024866007555, 
    0.0314432, 0.00016199393715732316,
    0.0328509, 0.00013282294405464308,
    0.0343000, 0.0001087606908988991, 
    0.0357911, 0.00008922050759153071,
    0.0373248, 0.00007363305964916886, 
    0.0389017, 0.0000614529666759468,
    0.0405224, 0.00005216452191889235, 
    0.0421875, 0.000045286448211470624, 
    0.0438976, 0.00004037565159446315,
    0.0456533, 0.000037029959957419186, 
    0.0474552, 0.00003488985915909477, 
    0.0493039, 0.00003363926270091007,
    0.0512000, 0.000033005372424509234,
    0.0531441, 0.000032757706334260305, 
    0.0551368, 0.00003270638517018567,
    0.0571787, 0.00003269978130943676, 
    0.0592704, 0.000032621641966762896, 
    0.0614125, 0.00003238780337245715,
    0.0636056, 0.00003194261343313779, 
    0.0658503, 0.000031255178304303706,
    0.0681472, 0.000030315542534001086,
    0.0704969, 0.000029130904442776207, 
    0.0729000, 0.00002772195677639521, 
    0.0753571, 0.000026119434189217896,
    0.0778688, 0.000024360927825684972, 
    0.0804357, 0.000022488022677111405,
    0.0830584, 0.000020543791127592652,
    0.0857375, 0.00001857066578056388, 
    0.0884736, 0.000016608700053364467,
    0.0912673, 0.00001469421276496351, 
    0.0941192, 0.000012858801942642564,
    0.0970299, 0.000011128703705451162, 
    0.1000000, 0.000009524464499350071, 
    0.1025000, 0.000008304284561096902,
    0.10707106781186548, 0.000006378863948404085,
    0.11299038105676659, 0.000004438626625335065,
    0.12000000000000001, 0.0000028385843866415056,
    0.12795084971874737, 0.0000017336098760834946,
    0.13674234614174768, 0.0000011107060395208632,
    0.14630064794363035, 0.0000008472961368628182,
    0.15656854249492380, 0.0000007830295595248482,
    0.16750000000000000, 0.0000007792953645741269, 
    0.17905694150420948, 0.000000750588123737054, 
    0.19120718173477352, 0.0000006671745565309263,
    0.20392304845413264, 0.0000005390988838480518,
    0.21718041645257968, 0.00000039433233735038467,
    0.23095800853708795, 0.0000002607233948375059,
    0.24523687548277814, 0.00000015603351975176372,
    0.26000000000000000, 0.00000008575145533681809, 
    0.27523198908875060, 0.00000004591902413678131,
    0.29091883092036785, 0.000000027794966055516582,
    0.30704769981818203, 0.000000022030344354728375,
    0.32360679774997900, 0.000000021255198974857916,
    0.34058522398518165, 0.000000020989694752832348,
    0.35797286679028860, 0.000000019358850624701225,
    0.37576031259048137, 0.000000016236996006081502,
    0.39393876913398140, 0.00000001232973695502864,
    0.41250000000000000, 0.000000008482448978298669, 
    0.43143626838353100, 0.000000005301772797143329,
    0.45074028853269765, 0.0000000030447884289450813,
    0.47040518354904270, 0.0000000016752912555232143,
    0.49042444851725164, 0.0000000009873809252225286,
    0.51079191812887460, 0.0000000007259577814951234,
    0.53150173811932670, 0.0000000006691611462022178,
    0.55254833995939050, 0.0000000006660149313539346,
    0.57392641833938740, 0.000000000638925502797425,
    0.59563091106185060, 0.0000000005662931900980605,
    0.61765698102121640, 0.000000000459004730771499, 
    0.64000000000000000, 0.0000000003398665133116444,
    0.66265553405258530, 0.00000000023001637319393342,
    0.68561933028205270, 0.00000000014258371645004797,
    0.70888730484384380, 0.00000000008180421309258326,
    0.73245553203367590, 0.00000000004519155830870155,
    0.75632023433686700, 0.000000000026694132519602834,
    0.78047777333282540, 0.00000000001948877142839279,
    0.80492464136246510, 0.000000000017803181492484868,
    0.82965745387818800, 0.000000000017708719462840843,
    0.85467294240617910, 0.000000000017130192643114797,
    0.87996794805940580, 0.000000000015414921017030436,
    0.90553941554712270, 0.000000000012763487086011492,
    0.93138438763306110, 0.000000000009723752595136686,
    0.95750000000000000, 0.000000000006842867596215941, 
    0.98388347648318440, 0.000000000004489706855450743, 
    1.01053212463921340, 0.000000000002812256017312611,
    1.03744333162063730, 0.0000000000017773030390986641,
    1.06461456032966860, 0.000000000001243574351493885,
    1.09204334582718720, 0.0000000000010336306306373298,
    1.11972729197565380, 0.0000000000009861147527969138,
    1.14766406829670360, 0.000000000000983332769803212,
    1.17585140702608200, 0.0000000000009576684280359487,
    1.20428710035026690, 0.0000000000008841119881127114,
    1.23296899781061970, 0.0000000000007664567817730129,
    1.26189500386222520, 0.0000000000006230070463288393,
    1.29106307557576500, 0.0000000000004752598292292839,
    1.32047122047183070, 0.0000000000003408505660737346,
    1.35011749447801920, 0.0000000000002305172202883309,
    1.38000000000000010, 0.00000000000014802552035259043,
    1.41011688409851450, 0.00000000000009178197704376728,
    1.44046633676493350, 0.00000000000005703110945847888,
    1.47104658928863530, 0.00000000000003788079065020483,
    1.50185591271000460, 0.000000000000028767446419621273,
    1.53289261635336800, 0.000000000000025268256207980976,
    1.56415504643463200, 0.00000000000002435514109934346,
    1.59564158473880370, 0.000000000000024269883634360814,
    1.62735064736294290, 0.000000000000024207191291338275,
    1.65928068352044940, 0.000000000000023954863889606297,
    1.69143017440288600, 0.00000000000002358555911627845,
    1.72379763209582260, 0.000000000000023242590866880746,
    1.75638159854545600, 0.000000000000023023211925597352,
    1.78918064457298360, 0.000000000000022939923673686547,
    1.82219336893393020, 0.000000000000022931646824712273,
    1.85541839741982880, 0.00000000000002289787729324961,
    1.88885438199983200, 0.000000000000022735648961416725,
    1.92250000000000000, 0.00000000000002236743085689408, 
    1.95635395331817060, 0.000000000000021755481157474682, 
    1.99041496767244230, 0.0000000000000209034241797195,
    2.02468179188145300, 0.000000000000019848667736813127,
    2.05915319717473850, 0.000000000000018650118296047667,
    2.09382797653157660, 0.000000000000017375136933837762,
    2.12870494404681750, 0.000000000000016088482720047558,
    2.16378293432230900, 0.00000000000001484465083093834,
    2.19906080188259430, 0.000000000000013683875941961841,
    2.23453742061365630, 0.00000000000001263129782572552,
    2.27021168322355130, 0.000000000000011698394430965189,
    2.30608250072385120, 0.000000000000010885709523683106,
    2.34214880193086200, 0.000000000000010186032117431571,
    2.37840953298567470, 0.000000000000009587417943212703,
    2.41486365689212900, 0.000000000000009075695334740202,
    2.45151015307185100, 0.00000000000000863631472846488,
    2.48834801693555540, 0.00000000000000825555658609502,
    2.52537625946985800, 0.000000000000007921203199898935,
    2.56259390683888450, 0.000000000000007622815694191894, 
    2.60000000000000000, 0.000000000000007351754334922772};

// Iron:
double InterpolationListFe[192][2] = {
    0.0000000, 0.007708714989239153, 
    0.0001000, 0.0076093052706569485,
    0.0001331, 0.0075766594599204,
    0.0001728, 0.007537672935314042, 
    0.0002197, 0.007491851887643216,
    0.0002744, 0.007438731669425366, 
    0.0003375, 0.007377881350158115, 
    0.0004096, 0.007308908712254484,
    0.0004913, 0.007231463906437165, 
    0.0005832, 0.007145246017992584,
    0.0006859, 0.007050006696216314,
    0.0008000, 0.006945555098846328,
    0.0009261, 0.006831762595296850,
    0.0010648, 0.006708565866038321,
    0.0012167, 0.006575972190463427, 
    0.0013824, 0.006434061660855705,
    0.0015625, 0.006282990095653268,
    0.0017576, 0.006122990829170266, 
    0.0019683, 0.005954376665086176,
    0.0021952, 0.005777539129354056, 
    0.0024389, 0.005592948642803091,
    0.0027000, 0.005401152796032328,
    0.0029791, 0.005202773989732125,
    0.0032768, 0.004998505508455877, 
    0.0035937, 0.004789105970683600,
    0.0039304, 0.004575395448169053, 
    0.0042875, 0.004358246617895979,
    0.0046656, 0.004138581115519516, 
    0.0050653, 0.003917353588811202,
    0.0054872, 0.0036955480989264607,
    0.0059319, 0.0034741655782181196,
    0.0064000, 0.0032542130868616907,
    0.0068921, 0.0030366927736735043, 
    0.0074088, 0.002822589753955372, 
    0.0079507, 0.002612861897646956,
    0.0085184, 0.0024084265472237368,
    0.0091125, 0.0022101500367806975,
    0.0097336, 0.0020188379191218085, 
    0.0103823, 0.0018352241309121003, 
    0.0110592, 0.0016599632471773224,
    0.0117649, 0.0014936211449486604, 
    0.0125000, 0.001336670216161997, 
    0.0132651, 0.0011894841390874796,
    0.0140608, 0.0010523339197457768, 
    0.0148877, 0.0009253862199419865, 
    0.0157464, 0.0008087046238411683,
    0.0166375, 0.0007022495313464513, 
    0.0175616, 0.0006058833288807683,
    0.0185193, 0.0005193742125612004, 
    0.0195112, 0.00044240328659635544,
    0.0205379, 0.00037457236743847325,
    0.0216000, 0.0003154132836507223,
    0.0226981, 0.0002643976435565329, 
    0.0238328, 0.0002209479515594144, 
    0.0250047, 0.00018444893238844128,
    0.0262144, 0.00015425921907910177, 
    0.0274625, 0.0001297229147462644, 
    0.0287496, 0.00011018099247793085,
    0.0300763, 0.00009498215835821136, 
    0.0314432, 0.00008349297682658389, 
    0.0328509, 0.00007510705430462801,
    0.0343000, 0.00006925310693551514, 
    0.0357911, 0.00006540177491144265,
    0.0373248, 0.00006307107022790397, 
    0.0389017, 0.00006183043342529447,
    0.0405224, 0.00006130331964174271, 
    0.0421875, 0.00006116839555061044, 
    0.0438976, 0.00006115937107315936,
    0.0456533, 0.00006106357341778097, 
    0.0474552, 0.00006071938840559449, 
    0.0493039, 0.000060012721598843254,
    0.0512000, 0.000058872651414854114,
    0.0531441, 0.00005726645974185306, 
    0.0551368, 0.00005519423194449544,
    0.0571787, 0.000052683217986204035, 
    0.0592704, 0.0000497821395983702, 
    0.0614125, 0.000046555616036453895,
    0.0636056, 0.000043078863334367344, 
    0.0658503, 0.000039432800076813155,
    0.0681472, 0.000035699667956018545,
    0.0704969, 0.00003195924844101546, 
    0.0729000, 0.00002828572912602835, 
    0.0753571, 0.00002474524600369312,
    0.0778688, 0.000021394101724706873, 
    0.0804357, 0.000018277636126516478,
    0.0830584, 0.000015429704478946394,
    0.0857375, 0.000012872701718402775, 
    0.0884736, 0.000010618057763141534,
    0.0912673, 0.000008667120030095286, 
    0.0941192, 0.000007012334488834134,
    0.0970299, 0.0000056386358774760945, 
    0.1000000, 0.000004524960587955847, 
    0.1025000, 0.0000037827485565902246,
    0.1070710678118655, 0.000002804672477426654,
    0.1129903810567666, 0.0000020818562306035776,
    0.1200000000000000, 0.0000017205444421616975,
    0.1279508497187474, 0.0000016233114847922,
    0.1367423461417477, 0.000001616980335352853,
    0.1463006479436304, 0.0000015571977292403035,
    0.1565685424949238, 0.0000013811612377381518,
    0.1675000000000000, 0.0000011057741992234024, 
    0.1790569415042095, 0.000000792411410993873, 
    0.1912071817347735, 0.0000005061277501663869,
    0.2039230484541326, 0.00000028870626544398757,
    0.2171804164525797, 0.00000015117661703187741,
    0.2309580085370879, 0.00000008091264905631378,
    0.2452368754827781, 0.00000005450687750140146, 
    0.2600000000000000, 0.00000004911693439204673,
    0.2752319890887506, 0.00000004879191729001772,
    0.2909188309203679, 0.000000045753714371640426,
    0.3070476998181820, 0.000000038481315591556425,
    0.3236067977499790, 0.000000028739508279610767,
    0.3405852239851817, 0.00000001905312247888031,
    0.3579728667902886, 0.000000011250402372743096,
    0.3757603125904814, 0.000000006026355626982868,
    0.3939387691339814, 0.000000003152950004600945,
    0.4125000000000000, 0.000000001930135922162648,
    0.4314362683835310, 0.0000000015954129563820765, 
    0.4507402885326977, 0.0000000015677111220793877,
    0.4704051835490427, 0.000000001521613517798182,
    0.4904244485172516, 0.0000000013483619647782546,
    0.5107919181288746, 0.0000000010705880392867956,
    0.5315017381193267, 0.0000000007602201673841345,
    0.5525483399593905, 0.0000000004837058037113819,
    0.5739264183393874, 0.0000000002780140851208741,
    0.5956309110618506, 0.0000000001493723111149711,
    0.6176569810212164, 0.00000000008350748755836623,
    0.6400000000000000, 0.00000000005816017449643092, 
    0.6626555340525853, 0.000000000052569309371636114, 
    0.6856193302820527, 0.00000000005226661175184759,
    0.7088873048438438, 0.00000000004985921996238874,
    0.7324555320336759, 0.00000000004343306133243705,
    0.7563202343368670, 0.00000000003417207324780026,
    0.7804777733328254, 0.00000000002426722446523826,
    0.8049246413624651, 0.000000000015588081548969152,
    0.8296574538781880, 0.000000000009134856941010168,
    0.8546729424061791, 0.0000000000050486302464797994,
    0.8799679480594058, 0.0000000000029000814299257534,
    0.9055394155471227, 0.0000000000020307616922138207,
    0.9313843876330611, 0.0000000000018155409147728499,
    0.9575000000000000, 0.000000000001802392048853609, 
    0.9838834764831844, 0.0000000000017436845070837145, 
    1.0105321246392134, 0.0000000000015589154303949347,
    1.0374433316206373, 0.0000000000012703871797405537,
    1.0646145603296686, 0.0000000000009419641570465203,
    1.0920433458271872, 0.00000000000063626245395524,
    1.1197272919756538, 0.00000000000039335933077615493,
    1.1476640682967036, 0.00000000000022669587549747528,
    1.1758514070260820, 0.00000000000012910846120372429,
    1.2042871003502669, 0.0000000000000824355919133146,
    1.2329689978106197, 0.0000000000000662369640694646,
    1.2618950038622252, 0.00000000000006350807101684354,
    1.2910630755757650, 0.00000000000006310659081008146,
    1.3204712204718307, 0.00000000000005966138619535146,
    1.3501174944780192, 0.0000000000000520855491092563,
    1.3800000000000001, 0.0000000000000416941120038576,
    1.4101168840985145, 0.00000000000003058721457939205,
    1.4404663367649335, 0.00000000000002059469495900529,
    1.4710465892886353, 0.000000000000012798677417515134,
    1.5018559127100046, 0.000000000000007492856381863059,
    1.5328926163533680, 0.000000000000004387601678531686,
    1.5641550464346320, 0.0000000000000028926722945549504,
    1.5956415847388037, 0.000000000000002365526897806384,
    1.6273506473629429, 0.0000000000000022730986752455535,
    1.6592806835204494, 0.000000000000002261238583102665,
    1.6914301744028860, 0.0000000000000021529562627426844,
    1.7237976320958226, 0.000000000000001905920936622066,
    1.7563815985454560, 0.0000000000000015569539563929381,
    1.7891806445729836, 0.0000000000000011725750100474937,
    1.8221933689339302, 0.0000000000000008149350718018938,
    1.8554183974198288, 0.0000000000000005246344011702202,
    1.8888543819998320, 0.0000000000000003171305486995996,
    1.9225000000000000, 0.00000000000000018755465286048785, 
    1.9563539533181706, 0.00000000000000011896804943153943, 
    1.9904149676724423, 0.00000000000000009043118150850742,
    2.0246817918814530, 0.00000000000000008289909306750262,
    2.0591531971747385, 0.0000000000000000823674297755631,
    2.0938279765315766, 0.0000000000000000806269271310609,
    2.1287049440468175, 0.00000000000000007442337044321555,
    2.1637829343223090, 0.00000000000000006387340987753255,
    2.1990608018825943, 0.000000000000000050809448897434086,
    2.2345374206136563, 0.000000000000000037462302031901945,
    2.2702116832235513, 0.000000000000000025639988230037084,
    2.3060825007238512, 0.00000000000000001637900044080695,
    2.3421488019308620, 0.000000000000000009944902730005644,
    2.3784095329856747, 0.000000000000000006030472392744876, 
    2.4148636568921290, 0.00000000000000000401846692572576, 
    2.4515101530718510, 0.000000000000000003217805287151963, 
    2.4883480169355554, 0.00000000000000000302710376533775, 
    2.5253762594698580, 0.00000000000000000301615808839364, 
    2.5625939068388845, 0.000000000000000002939240754657754, 
    2.6000000000000000, 0.0000000000000000027043040951614707};
        
//***************************************************
    bool is_nan(double x) { return x != x; }  
//***************************************************

//***************************************************
    std::random_device entropySource;
    std::mt19937 generator(entropySource());
    std::uniform_real_distribution<double> realdistribution(0.0,1.0);
//***************************************************

//*******************************************************
// Interpolation functions for the form factor grids
//*******************************************************

double Interpolation(double x, int r){

    double x1, y1, x2, y2, slope, interp;

    for (int i = 0; i < r-1; i++){
        if (InterpolationList[i][0] < x && x < InterpolationList[i+1][0]){
            // Set the x and y values of the two points
            x1 = InterpolationList[i][0];
            x2 = InterpolationList[i+1][0];
            y1 = InterpolationList[i][1];
            y2 = InterpolationList[i+1][1];
        }
    }
    
    // Calculate the slope of the line between the two points
    slope = (y2-y1)/(x2-x1);
    // Calculate the y value for the given x value
    interp = slope*(x-x1)+y1;

    return interp;
}

double InverseInterpolation(double y, int r){

    double x1, y1, x2, y2, slope, invinterp;

    for (int i = 0; i < r-1; i++){
        if (InterpolationList[i][1] > y && y > InterpolationList[i+1][1]){
            // Set the x and y values of the two points
            x1 = InterpolationList[i][0];
            x2 = InterpolationList[i+1][0];
            y1 = InterpolationList[i][1];
            y2 = InterpolationList[i+1][1];
        }
    }
    							    
    // Calculate the slope of the line between the two points
    slope = (x2-x1)/(y2-y1);   
    // Calculate the y value for the given x value
    invinterp = slope*(y-y1)+x1;

    return invinterp;
}



//***********************************************
// proton and neutron form factors
//***********************************************

// dipole form factor
double GD(double q2){double ff;
  
  ff = 1/(1+q2/0.71)/(1+q2/0.71);
  
  return ff;}

  
// magnetic form factor of the proton (from 0812.3539)
double GMp(double q2){double ff;
  
  ff = mup*(1+apM1*q2/4/Mproton/Mproton)/(1+bpM1*q2/4/Mproton/Mproton
             +bpM2*q2*q2/4/4/Mproton/Mproton/Mproton/Mproton
	     +bpM3*q2*q2*q2/4/4/4/Mproton/Mproton/Mproton/Mproton/Mproton/Mproton);
  
  return ff;}

  
// electric form factor of the proton (from 0812.3539)
double GEp(double q2){double ff;
  
  ff = (1+apE1*q2/4/Mproton/Mproton)/(1+bpE1*q2/4/Mproton/Mproton
             +bpE2*q2*q2/4/4/Mproton/Mproton/Mproton/Mproton
	     +bpE3*q2*q2*q2/4/4/4/Mproton/Mproton/Mproton/Mproton/Mproton/Mproton);
  
  return ff;}
  
  
// magnetic form factor of the neutron (from 0812.3539)
double GMn(double q2){double ff;
  
  ff = mun*(1+anM1*q2/4/Mneutron/Mneutron)/(1+bnM1*q2/4/Mneutron/Mneutron
             +bnM2*q2*q2/4/4/Mneutron/Mneutron/Mneutron/Mneutron
	     +bnM3*q2*q2*q2/4/4/4/Mneutron/Mneutron/Mneutron/Mneutron/Mneutron/Mneutron);
  
  return ff;}
  
  
// electric form factor of the neutron (from 0812.3539)
double GEn(double q2){double ff;
  
  ff = ffA*q2/4/Mneutron/Mneutron/(1+ffB*q2/4/Mneutron/Mneutron)*GD(q2);
  
  return ff;}


  
//***********************************************
// Pauli blocking factor for nucleons scattering inside the nucleus (from Lovseth/Radomski)
//***********************************************

double Pauli(double p){double blockingfactor;
  
  if (p > 2*0.235){blockingfactor = 1;}
  else {blockingfactor = 1.5*p/2/0.235 - 0.5*p*p*p/8/0.235/0.235/0.235;}
  
  return blockingfactor;}
  

//***********************************************
// define the trident processes
//***********************************************

void SetTridentProcess(){

     if(process == 1){ // nu_e -> nu_e e+ e-
         m3 = me; m4 = me;
         GVSM = 0.5 + 2*sW2; GASM = -0.5;
	     anti = 0;
         PDG1 = 12; PDG2 = 12; PDG3 = -11; PDG4 = 11;}
    
    else if(process == 2){ // nu_e -> nu_e mu+ mu-
         m3 = mmu; m4 = mmu;
         GVSM = -0.5 + 2*sW2; GASM = 0.5;
	     anti = 0;
         PDG1 = 12; PDG2 = 12; PDG3 = -13; PDG4 = 13;}
         
    else if(process == 3){ // nu_e -> nu_mu mu+ e-
         m3 = mmu; m4 = me; 
         GVSM = 1.0; GASM = -1.0;
         anti = 0; 
         PDG1 = 12; PDG2 = 14; PDG3 = -13; PDG4 = 11;}
         
    else if(process == 4){ // anti-nu_e -> anti-nu_e e+ e-
         m3 = me; m4 = me; 
         GVSM = 0.5 + 2*sW2; GASM = -0.5;
         anti = 1;
         PDG1 = -12; PDG2 = -12; PDG3 = -11; PDG4 = 11;}
         
    else if(process == 5){ // anti-nu_e -> anti-nu_e mu+ mu-
         m3 = mmu; m4 = mmu; 
         GVSM = -0.5 + 2*sW2; GASM = 0.5;
         anti = 1;
         PDG1 = -12; PDG2 = -12; PDG3 = -13; PDG4 = 13;}
    
    else if(process == 6){ // anti-nu_e -> anti-nu_mu e+ mu-
         m3 = me; m4 = mmu; 
         GVSM = 1.0; GASM = -1.0;
         anti = 1;
         PDG1 = -12; PDG2 = -14; PDG3 = -11; PDG4 = 13;}
    
    else if(process == 7){ // nu_mu -> nu_mu e+ e-
         m3 = me; m4 = me;
         GVSM = -0.5 + 2*sW2; GASM = 0.5;
	     anti = 0;
         PDG1 = 14; PDG2 = 14; PDG3 = -11; PDG4 = 11;}
         
    else if(process == 8){ // nu_mu -> nu_mu mu+ mu-
         m3 = mmu; m4 = mmu;
         GVSM = 0.5 + 2*sW2; GASM = -0.5;
         anti = 0;  
         PDG1 = 14; PDG2 = 14; PDG3 = -13; PDG4 = 13;}
         
    else if(process == 9){ // nu_mu -> nu_e e+ mu-
         m3 = me; m4 = mmu; 
         GVSM = 1.0; GASM = -1.0;
         anti = 0;
         PDG1 = 14; PDG2 = 12; PDG3 = -11; PDG4 = 13;}
         
    else if(process == 10){ // anti-nu_mu -> anti-nu_mu e+ e-
         m3 = me; m4 = me; 
         GVSM = -0.5 + 2*sW2; GASM = 0.5;
         anti = 1;  
         PDG1 = -14; PDG2 = -14; PDG3 = -11; PDG4 = 11;}

    else if(process == 11){ // anti-nu_mu -> anti-nu_mu mu+ mu-
         m3 = mmu; m4 = mmu; 
         GVSM = 0.5 + 2*sW2; GASM = -0.5;
         anti = 1;
         PDG1 = -14; PDG2 = -14; PDG3 = -13; PDG4 = 13;}

    else if(process == 12){ // anti-nu_mu -> anti-nu_e mu+ e-
         m3 = mmu; m4 = me; 
         GVSM = 1.0; GASM = -1.0; 
         anti = 1;
         PDG1 = -14; PDG2 = -12; PDG3 = -13; PDG4 = 11;}

    return;
  
}


//***********************************************
// set the nuclear parameters
//***********************************************

void SetNuclearParameters(){
            
    if (material.compare("Ar") == 0){
        A = 40;
        Z = 18;
        M = MArgon;
	    M2 = M*M;
	    for (int jj = 0; jj < 192; jj++){
            for (int kk = 0; kk < 2; kk++){
                InterpolationList[jj][kk] = InterpolationListAr[jj][kk];}}}
            
    else if (material.compare("Fe") == 0){
        A = 56;
        Z = 26;
        M = MIron;
	    M2 = M*M;
	    for (int jj = 0; jj < 192; jj++){
            for (int kk = 0; kk < 2; kk++){
                InterpolationList[jj][kk] = InterpolationListFe[jj][kk];}}}
            
    else if (material.compare("proton") == 0){
        A = 1;
        Z = 1;
        M = Mproton;
	    M2 = M*M;
	    for (int jj = 0; jj < 192; jj++){
            for (int kk = 0; kk < 2; kk++){
                InterpolationList[jj][kk] = InterpolationListProton[jj][kk];}}}
            
    else if (material.compare("neutron") == 0){
        A = 1;
        Z = 1; // "charge" of the neutron is taken care by the form factor
        M = Mneutron;
	    M2 = M*M;
	    for (int jj = 0; jj < 192; jj++){
            for (int kk = 0; kk < 2; kk++){
                InterpolationList[jj][kk] = InterpolationListNeutron[jj][kk];}}}
            
    return;

}
    
    
//*******************************************************
// main program
//*******************************************************

int main(){
    
        // Define the trident process
        std::cout << "\n";
	    std::cout << "Select the trident process  [enter 1 - 12]\n\n";
	    std::cout << " [1] nu_e -> nu_e e+ e-                  [7] nu_mu -> nu_mu e+ e- \n";
	    std::cout << " [2] nu_e -> nu_e mu+ mu-                [8] nu_mu -> nu_mu mu+ mu- \n";
	    std::cout << " [3] nu_e -> nu_mu mu+ e-                [9] nu_mu -> nu_e e+ mu- \n";
	    std::cout << " [4] anti-nu_e -> anti-nu_e e+ e-        [10] anti-nu_mu -> anti-nu_mu e+ e- \n";
	    std::cout << " [5] anti-nu_e -> anti-nu_e mu+ mu-      [11] anti-nu_mu -> anti-nu_mu mu+ mu- \n";
	    std::cout << " [6] anti-nu_e -> anti-nu_mu e+ mu-      [12] anti-nu_mu -> anti-nu_e mu+ e- \n\n";
        std::cin >> process;
	    if(process != 1 && process != 2 && process != 3 && process != 4 && process != 5 && 
	       process != 6 && process != 7 && process != 8 && process != 9 && process != 10 && 
	       process != 11 && process != 12){
        std::cout << "\n Invalid selection \n";
	    return 0;}
	   
	SetTridentProcess();
 	
 	
	// Define the target material
	    std::cout << "\n";
        std::cout << "Select the target material  [enter Ar, Fe, proton, neutron] \n\n";
	    std::cout << " [Ar] Argon      [Fe] Iron \n\n";
	    std::cout << " [proton]  Proton inside an ideal Fermi gas  \n";  
	    std::cout << " [neutron] Neutron inside an ideal Fermi gas \n\n";
        std::cin >> material;
	    if(material.compare("Ar") != 0 && material.compare("Fe") != 0 &&
	       material.compare("proton") != 0 && material.compare("neutron") != 0 ){
	    std::cout << "\n Invalid selection \n";
	    return 0;}

	SetNuclearParameters();
	
	
	// Define the incoming neutrino spectrum
	    std::cout << "\n";
        std::cout << "Are you using a fixed neutrino energy or an energy distribution? \n\n";
	    std::cout << "[1] fixed neutrino energy \n\n";
        std::cout << "[2] Load flux from a ROOT file \n\n";
        std::cin >> energy_type;
	    if(energy_type.compare("1") != 0 && energy_type.compare("2") != 0 ){
	    std::cout << "\n Invalid selection \n";
	    return 0;}
        
        if(energy_type.compare("1") == 0){
	    Enu = 0.0;
	    std::cout << "\n";
        std::cout << "Enter the energy of the neutrino beam (in GeV) \n\n";
        std::cin >> Enu;}
	       
        if(energy_type.compare("2") == 0){
            string flux_file;
            string is_antinu;
            string flavor;
            std::cout << "\n";
            std::cout << "Enter the path to the ROOT flux file \n\n";
            std::cin >> flux_file;

            // Use the selected process to determine neutrino flavor and particle/antiparticle
            int target_pdg = 0;
            if (process <= 6) { // nu_e processes
                target_pdg = 12;
                target_pdg = (process >= 4) ? -12 : 12;
            } else { // nu_mu processes
                target_pdg = 14;
                target_pdg = (process >= 10) ? -14 : 14;
            }
            
            LoadFluxFromROOT(flux_file, target_pdg);}
        
        
        // Define the particle physics model
        std::cout << "\n";
        std::cout << "Select the model \n\n";
	    std::cout << "[4F]      Model independent 4 Fermi operators \n";
	    std::cout << "[SM]      Standard Model \n";
	    std::cout << "[LmuLtau] Standard Model + Z' gauge boson based on L_mu - L_tau \n\n";
        std::cin >> model;
    	if(model.compare("SM") != 0 && model.compare("4F") != 0 && model.compare("LmuLtau") != 0 ){
	    std::cout << "\n Invalid selection \n";
	    return 0;}
	   	
        if(model.compare("SM") == 0){
        GAtot=0.0; GVtot=0.0; GP=0.0; MZP=1000.0;}
	
	    if(model.compare("4F") == 0){
        GP=0.0; MZP=1000.0;
	    std::cout << "\n";
        std::cout << "Enter the value of the vector coupling g_V \n\n";
        std::cin >> GVtot; 
	    std::cout << "\n";
        std::cout << "Enter the value of the axial-vector coupling g_A \n\n";
        std::cin >> GAtot;}
        
        if(model.compare("LmuLtau") == 0){
	    GAtot=0.0; GVtot=0.0;
        std::cout << "\n";
        std::cout << "Enter the value of the L_mu - L_tau gauge coupling g' \n\n";
        std::cin >> GP; 
	    std::cout << "\n";
        std::cout << "Enter the value of the Z' mass (in GeV) \n\n";
        std::cin >> MZP;}
        
        
        // Cross section or event generation
        std::cout << "\n";
        std::cout << "You can compute the trident [CrossSection] or [GenerateEvents] \n\n";
        std::cin >> command;
	    if(command.compare("CrossSection") != 0 && command.compare("GenerateEvents") != 0 ){
	    std::cout << "\n Invalid selection \n";
	    return 0;}
	   
        if(command.compare("GenerateEvents") == 0){
	    std::cout << "\n";
        std::cout << "Enter the number of events to be generated \n\n";
        std::cin >> Nevents; 
	    ::data = new double[20*Nevents];
	    std::cout << "\n";
        std::cout << "Enter the name of the output file \n\n";
        std::cin >> filename_out;}
        
        
        // Compute cross section
        if(command.compare("CrossSection") == 0){
	    ComputeCrossSection();
        std::cout << "\n\n";
	    std::cout << "The trident cross section is  ( " << crosssectionresult << " +- " << deltacrosssectionresult << " ) fb  \n";
        std::cout << "(uncertainty is the statistical uncertainty of the numerical phase space integration) \n\n";
        std::cout << "A temporary file with the cross section values has been create/added to: temp_xsec_file.txt \nPlease clear this file between different processes/runs. \n\n";
        WriteXsecTempFile("temp_xsec_file.txt");}
        
        // Generate Events
        if(command.compare("GenerateEvents") == 0){
        FindMaxWeight();
	    GenerateEvents();
	    WriteEventFile(filename_out.c_str());}
	   
	      
	return 0;
}

//********************************************************************
// Generate a random point in phase space
//********************************************************************

void GenerateEvent(){
	
    if (energy_type.compare("1") == 0){
      eps1 = Enu;
    }
    else if (energy_type.compare("1") != 0){  
      bin = realdistribution(generator)*length_probability_list;
      eps1 = realdistribution(generator)*(Enumax_list[bin]-Enumin_list[bin])+Enumin_list[bin];       
    }

    // Generate a random point if the neutrino energy is high enough.
    // Otherwise set flag to return a zero weight event.
   
    if ((1-(m3+m4)*(m3+m4)/2/(eps1*eps1)*(1+eps1/M))*(1-(m3+m4)*(m3+m4)/2/(eps1*eps1)*(1+eps1/M)) - (m3+m4)*(m3+m4)*(m3+m4)*(m3+m4)/4/(eps1*eps1*eps1*eps1)*(1+2*eps1/M) < 0) {
        zeroweight=1;
	for (int jj = 0; jj < 4; jj++){
        for (int kk = 0; kk < 4; kk++){
        event[jj][kk] = 0.0;}}
        //std::cout << "The neutrino energy is too small to create the charged leptons";
        return;}
        
    else {zeroweight=0; GenerateRandomPoint();}
    
    // Rotate around z-axis by random angle
    Theta = Twopi*realdistribution(generator);
    sintheta = sin(Theta);
    costheta = cos(Theta);

    // Define the event
    event[0][0] = Enuin;
    event[0][1] = pnuinx;
    event[0][2] = pnuiny;
    event[0][3] = pnuinz;
    
    event[1][0] = Enuout;
    event[1][1] = pnuoutx*costheta+pnuouty*sintheta;
    event[1][2] = -pnuoutx*sintheta+pnuouty*costheta;
    event[1][3] = pnuoutz;
    
    event[2][0] = Elminus;
    event[2][1] = plminusx*costheta+plminusy*sintheta;
    event[2][2] = -plminusx*sintheta+plminusy*costheta;
    event[2][3] = plminusz;
    
    event[3][0] = Elplus;
    event[3][1] = plplusx*costheta+plplusy*sintheta;
    event[3][2] = -plplusx*sintheta+plplusy*costheta;
    event[3][3] = plplusz;

    event[4][0] = Eprime;
    event[4][1] = Pprimex*costheta+Pprimey*sintheta;
    event[4][2] = -Pprimex*sintheta+Pprimey*costheta;
    event[4][3] = Pprimez;
    
    return;
}

//*************************************************************************

void GenerateRandomPoint(){
 
    g = eps1/M;
    x0 = M*eps1; // (B.1) of Lovseth, Radomski
    
    x1max = 2*eps1*eps1/(1+2*g)*(1-(m3+m4)*(m3+m4)/2/(eps1*eps1)*(1+g)+sqrt((1-(m3+m4)*(m3+m4)/2/(eps1*eps1)*(1+g))*(1-(m3+m4)*(m3+m4)/2/(eps1*eps1)*(1+g))-(m3+m4)*(m3+m4)*(m3+m4)*(m3+m4)/4/(eps1*eps1*eps1*eps1)*(1+2*g)));
    x1min = (m3+m4)*(m3+m4)*(m3+m4)*(m3+m4)/x1max/(1+2*g); // (B.4) of Lovseth, Radomski
    
    u1max = Interpolation(x1min, 192);
    // put hard cut off for the form factor
    // at some point the interpolation function becomes ureliable
    if (x1max > 1.0){u1min = Interpolation(1.0, 192);}
    else{u1min = Interpolation(x1max, 192);}
    if (x1min > 1.0){u1min = Interpolation(x1min, 192);}

    u1 = u1min + (u1max-u1min)*realdistribution(generator);
    x1 = InverseInterpolation(u1, 192);
    
    
    u2max = (1+2*g)*(x1max-x1)*(x1-x1min)/((m3+m4)*(m3+m4)+x1*(1+g)+2*eps1*sqrt((x1+(x1*x1)/4/M2)));
    u2min = 0.0; // (B.5) of Lovseth, Radomski
    
    u2 = u2min + (u2max-u2min)*realdistribution(generator);
    x2 = (u2+x1+(m3+m4)*(m3+m4))/2;
    
    
    WB = sqrt(u2+(m3+m4)*(m3+m4));
    WB2 = WB*WB;
    yplus = (WB2-m3*m3-m4*m4)+sqrt(WB2*WB2+(m3*m3-m4*m4)*(m3*m3-m4*m4)-2*m3*m3*WB2-2*m4*m4*WB2);
    yminus = 4*m3*m3*m4*m4/yplus; // (B.9b) of Lovseth, Radomski
    
    D3max = m3*m3+x1*m4*m4/(WB2)+x2*yplus/(WB2);
    D3min = m3*m3+x1*m4*m4/(WB2)+x2*yminus/(WB2); // (B.9b) of Lovseth, Radomski
    
    u3max = log(D3max);
    u3min = log(D3min); // (B.9a) of Lovseth, Radomski
    u3 = u3min + (u3max-u3min)*realdistribution(generator);

    x3 = (exp(u3)-x1)/2; // (B.8) of Lovseth, Radomski
    D3 = x1+2*x3;
    D32 = D3*D3;
    
    u4max = ((D3max-D3)*(D3-D3min)*WB2/x1/(u2+2*m3*(m3+m4)+2*x3*(x2-x1)/x1+2*x2*sqrt(x3*x3+m3*m3*x1)/x1))*((D3max-D3)*(D3-D3min)*WB2/x1/(u2+2*m3*(m3+m4)+2*x3*(x2-x1)/x1+2*x2*sqrt(x3*x3+m3*m3*x1)/x1));
    //  (B.10) of Lovseth, Radomski (square is according to Brown et al.)
    u4min = 0.0;
    u4 = u4min + (u4max-u4min)*realdistribution(generator);

    x5 = x2-x3-(m4*m4-m3*m3+x1+sqrt(u4))/2; // (B.8) of Lovseth, Radomski
    
    u5max = Twopi; // (B.11) of Lovseth, Radomski
    u5min = 0.0;
    u5 = u5min + (u5max-u5min)*realdistribution(generator);

    phi3 = u5;
    
    P2 = M2*(u2max-u2)/2*(x2+eps1*x1/2/M+eps1*sqrt(x1+x1*x1/4/M2))/(x2*x2); // (B.13) of Lovseth, Radomski
    P5 = x1/2*(sqrt(u4max)-sqrt(u4))*((sqrt(u4max)-sqrt(u4))/2+2*x2*sqrt(x3*x3+m3*m3*x1)/x1)/(x2*x2);
    
    WC = sqrt(sqrt(u4)+m4*m4); // from (24) of Lovseth, Radomski
    WC2 = WC*WC;
    qc = 1/WC*sqrt((x2-x3)*(x2-x3)-2*x1*x5+m3*m3*x1); // (B.16) of Lovseth, Radomski
    WCqc = sqrt((x2-x3)*(x2-x3)-2*x1*x5+m3*m3*x1);
    
    x7 = (x0*x1*x5+x0*x2*x3-x1*x2*x5/2)/(x2*x2)-sqrt(P2*P5)*cos(u5); // (B.12) of Lovseth, Radomski
    
    u7max = Twopi; // (B.17) of Lovseth, Radomski
    u7min = 0.0;
    u7 = u7min + (u7max-u7min)*realdistribution(generator);

    phi4 = u7;
    
    D4max = m4*m4*(WC2+2*x5-m3*m3)/WC2+(1-m4*m4/WC2)/2*(WC2+x1+2*x5-m3*m3+sqrt((WC2+2*x5+x1-m3*m3)*(WC2+2*x5+x1-m3*m3)-4*x1*(2*x5-m3*m3))); // (B.18) of Lovseth, Radomski
    D4min = m4*m4*(WC2+2*x5-m3*m3)/WC2+2*(1-m4*m4/WC2)*x1*(2*x5-m3*m3)/((WC2+x1+2*x5-m3*m3)+sqrt((WC2+x1+2*x5-m3*m3)*(WC2+x1+2*x5-m3*m3)-4*x1*(2*x5-m3*m3))); // (B.19) of Lovseth, Radomski

    u6max = log(D4max); // (B.17) of Lovseth, Radomski
    u6min = log(D4min);
    u6 = u6min + (u6max-u6min)*realdistribution(generator);

    
    x4 = (-x1+exp(u6))/2; // (B.15) of Lovseth, Radomski
    D4 = x1+2*x4;
    D42 = D4*D4;
    D3D4 = D3*D4;
    
    P4 = (D4max-D4)*(D4-D4min)/4/(qc*qc); // below (B.21) of Lovseth, Radomski
    
    x6 = ((WC2+m4*m4)/2*(x2*(x2-x3)-x1*x5)+x4*(x2-x5)*(x2-x1-x3)-x4*x2*WC2)/WCqc/WCqc-x2*sqrt(P4*P5)*cos(phi4)/WCqc; // (B.21) of Lovseth, Radomski
    
    // x8 result in (B.21) of Lovseth, Radomski is missing a term according to Brown et al. and is not used in the following
    
    // below (B.20) in Lovseth, Radomski
    P0C = (x0-0.5*x1-x7)/WC; // note the typo ...x7/WC) in Lovseth, Radomski
    PC = sqrt(P0C*P0C-M2);
    q0C = (x2-x1-x3)/WC;
    qC = sqrt(q0C*q0C+x1);
    eps1C = (x2-x5)/WC;
    eps4C = (WC2+m4*m4)/2/WC;
    p4C = sqrt(u4)/2/WC;
    
    cos4 = (eps4C*q0C-x4)/p4C/qC;
    sin4 = sqrt(1-cos4*cos4);
    
    flagkinematics = 0;
      
    if(cos4*cos4>1.01){
      flagkinematics = 1; 
//      std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//      std::cout << "cos4^2-1 = " << (eps4C*q0C-x4)/p4C/qC*(eps4C*q0C-x4)/p4C/qC-1 << "\n\n";
    }
    
    if(1-cos4*cos4<1.0e-16){
      sin4=0.0; // adhoc fix
      cos4=1.0; // adhoc fix
    }
      
    cosPq = (P0C*q0C+x1/2)/PC/qC;
    sinPq = sqrt(1-cosPq*cosPq);
    
    if(1-cosPq*cosPq<1.0e-16){
      flagkinematics = 1;
//      std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//      std::cout << "cosPq^2-1 = " << (P0C*q0C+x1/2)/PC/qC*(P0C*q0C+x1/2)/PC/qC-1 << "\n\n";
    }
    
    cosP1q = (eps1C*q0C-x2)/eps1C/qC;
    sinP1q = sqrt(1-cosP1q*cosP1q);
    
    if(1-cosP1q*cosP1q<1.0e-16){
      flagkinematics = 1;
//      std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//      std::cout << "cosP1q^2-1 = " << (eps1C*q0C-x2)/eps1C/qC*(eps1C*q0C-x2)/eps1C/qC-1 << "\n\n";
    }
   
    cosPp1 = (P0C*eps1C-x0)/eps1C/PC;
    sinPp1 = sqrt(1-cosPp1*cosPp1);
    
    if(1-cosPp1*cosPp1<1.0e-16){
      flagkinematics = 1;
//      std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//      std::cout << "cosPp1^2-1 = " << (P0C*eps1C-x0)/eps1C/PC*(P0C*eps1C-x0)/eps1C/PC-1 << "\n\n";
    }
   
    cosPhi = (cosPp1-cosPq*cosP1q)/(sinPq*sinP1q);
    sinPhi = sqrt(1-cosPhi*cosPhi);
    
    if(cosPhi>1.01){
      flagkinematics = 1;
//      std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//      std::cout << "cosPhi^2-1 = " << (cosPp1-cosPq*cosP1q)/(sinPq*sinP1q)*(cosPp1-cosPq*cosP1q)/(sinPq*sinP1q)-1 << "\n\n";
    }
      if(1-cosPhi*cosPhi<1.0e-16){
      sinPhi=0.0; // adhoc fix
      cosPhi=1.0; // adhoc fix
    }

    x8 = P0C*eps4C-PC*p4C*(cos4*cosPq+sin4*sinPq*(cos(phi4)*cosPhi-sin(phi4)*sinPhi)); // (B .20) in Lovseth, Radomski

    // (B.1) and (B.2) of Lovseth, Radomski
    p1P = -x0;
    q2 = x1;
    qp1 = -x2;
    qp3 = -x3;
    qp4 = -x4;
    p1p3 = -x5;
    p1p4 = -x6;
    p3P = -x7;
    p4P = -x8;
    Pq = x1*0.5;
    qP = Pq;
    p2P = x1*0.5-x0+x7+x8;
    qp2 = x1-x2+x3+x4;
    p1p2 = -x2+x5+x6;
    p2p3 = (m3*m3-m4*m4+x1)*0.5-x2+x4+x6;
    p2p4 = (m4*m4-m3*m3+x1)*0.5-x2+x3+x5;
    p3p4 = (m3*m3+m4*m4-x1)*0.5+x2-x3-x4-x5-x6;
    
   
    // Define the 4 momenta of the events
    
    Enuin = eps1;
    pnuinx = 0.0;
    pnuiny = 0.0;
    pnuinz = eps1;
    
    // note that signs are such that the metric of Lovseth, Radomski is taken into account
    
    Eq = -qP/M;
    qz = Eq+qp1/eps1;
    qy = sqrt(q2-2*Eq*qp1/eps1-qp1*qp1/eps1/eps1);
    qx = 0.0;
    
    Elplus = -p3P/M;
    plplusz = Elplus+p1p3/eps1; 
    plplusy = (Eq*Elplus+qp3-qz*plplusz)/qy;
    plplusx = sqrt(-2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1-plplusy*plplusy-m3*m3);

    Enuout = -p2P/M; 
    pnuoutz = Enuout+p1p2/eps1;
    pnuouty = (Eq*Enuout+qp2-qz*pnuoutz)/qy;
    pnuoutx = 1/plplusx*(p2p3-p1p2*p1p3/eps1/eps1-p1p2*Elplus/eps1-p1p3*Enuout/eps1-pnuouty*plplusy);
    
    Elminus = -p4P/M;
    plminusz = Elminus+p1p4/eps1;
    plminusy = (Eq*Elminus+qp4-qz*plminusz)/qy;
    plminusx = -plplusx-pnuoutx;
        
    // special case where the anti-muon has no momentum in x direction
    if (-2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1-plplusy*plplusy < 0){
       flagkinematics = 1;
//       std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//       std::cout << "Elplus = " << Elplus << "\n";
//       std::cout << "plplusz = " << plplusz << "\n";
//       std::cout << "plplusy = " << plplusy << "\n";
//       std::cout << "plplusx = " << plplusx << "\n\n";
    }
    if (-2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1-plplusy*plplusy-m3*m3 < 0){
        plplusx = 0.0;
	    plminusx = sqrt(-2*Elminus*p1p4/eps1-p1p4*p1p4/eps1/eps1-plminusy*plminusy-m4*m4);
	    pnuoutx = -plminusx;
    }
    
    // special case where both muon and anti-muon have no momentum in x direction
    if (-2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1-plplusy*plplusy-m3*m3 < 0 && -2*Elminus*p1p4/eps1-p1p4*p1p4/eps1/eps1-plminusy*plminusy < 0){
       flagkinematics = 1;
//       std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//       std::cout << "Elminus = " << Elminus << "\n";
//       std::cout << "plminusz = " << plminusz << "\n";
//       std::cout << "plminusy = " << plminusy << "\n";
//       std::cout << "plminusx = " << plminusx << "\n\n";
    }
    if (-2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1-plplusy*plplusy-m3*m3 < 0 && -2*Elminus*p1p4/eps1-p1p4*p1p4/eps1/eps1-plminusy*plminusy-m4*m4 < 0){
        plplusx = 0.0;
	    plminusx = 0.0;
	    pnuoutx = 0.0;
    }
   
    
    // special case where the momentum transfer to the nucleon has no y component    
    if (q2-2*Eq*qp1/eps1-qp1*qp1/eps1/eps1 < -q2){
       flagkinematics = 1;
//       std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//       std::cout << "Eq = " << Eq << "\n";
//       std::cout << "qz = " << qz << "\n";
//       std::cout << "qy = " << qy << "\n\n";
    }
    if (q2-2*Eq*qp1/eps1-qp1*qp1/eps1/eps1 < 0){
        qy = 0.0;
	
	    plplusy = sqrt(-2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1-m3*m3);
        plplusx = 0.0;
	
	    pnuouty = (Elplus*Enuout+p2p3-plplusz*pnuoutz)/plplusy;
        pnuoutx = sqrt(-2*Enuout*p1p2/eps1-p1p2*p1p2/eps1/eps1-pnuouty*pnuouty);
	
 	    plminusy = (Elplus*Elminus+p3p4-plplusz*plminusz)/plplusy;
        plminusx = -plplusx-pnuoutx;
    }
    
    
    // special case where the momentum transfer to the nucleon has no y component and the outgoing neutrino has no momentum in x direction   
    if (q2-2*Eq*qp1/eps1-qp1*qp1/eps1/eps1 < 0 && -2*Enuout*p1p2/eps1-p1p2*p1p2/eps1/eps1 < 0){
       flagkinematics = 1;
//       std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//       std::cout << "Enuout = " << Enuout << "\n";
//       std::cout << "pnuoutz = " << pnuoutz << "\n";
//       std::cout << "pnuouty = " << pnuouty << "\n";
//       std::cout << "pnuoutx = " << pnuoutx << "\n\n";
    }
    if (q2-2*Eq*qp1/eps1-qp1*qp1/eps1/eps1 < 0 && -2*Enuout*p1p2/eps1-p1p2*p1p2/eps1/eps1-pnuouty*pnuouty < 0){
        qy = 0.0;
	
	    plplusy = sqrt(-2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1-m3*m3);
        plplusx = 0.0;
	
	    pnuouty = (Elplus*Enuout+p2p3-plplusz*pnuoutz)/plplusy;
        pnuoutx = 0.0;
	
	    plminusy = (Elplus*Elminus+p3p4-plplusz*plminusz)/plplusy;
        plminusx = 0.0;
    }
    
    
    // special case where the momentum transfer to the nucleon and the momentum of the anti-muon have no y component
    if (q2-2*Eq*qp1/eps1-qp1*qp1/eps1/eps1 < 0 && -2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1 < 0){
       flagkinematics = 1;
//       std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//       std::cout << "Elplus = " << Elplus << "\n";
//       std::cout << "plplusz = " << plplusz << "\n";
//       std::cout << "plplusy = " << plplusy << "\n";
//       std::cout << "plplusx = " << plplusx << "\n\n";
    }
    if (q2-2*Eq*qp1/eps1-qp1*qp1/eps1/eps1 < 0 && -2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1-m3*m3 < 0){
        qy = 0.0;
	
	    plplusy = 0.0;
        plplusx = 0.0;
	
	    plminusy = sqrt(-2*Elminus*p1p4/eps1-p1p4*p1p4/eps1/eps1-m4*m4);
        plminusx = 0.0;
	
        pnuouty = -plminusy;
        pnuoutx = 0.0;
    }
    
    
    // special case where the momentum transfer to the nucleon and the momenta of the muon and anti-muon have no y component
    if (q2-2*Eq*qp1/eps1-qp1*qp1/eps1/eps1 < 0 && -2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1-m3*m3 < 0 && -2*Elminus*p1p4/eps1-p1p4*p1p4/eps1/eps1 < 0){
       flagkinematics = 1;
//       std::cout << "Warning: event with extreme kinematics. Numerical precision is insufficient. \n";
//       std::cout << "Elminus = " << Elminus << "\n";
//       std::cout << "plminusz = " << plminusz << "\n";
//       std::cout << "plminusy = " << plminusy << "\n";
//       std::cout << "plminusx = " << plminusx << "\n\n";
    }
    if (q2-2*Eq*qp1/eps1-qp1*qp1/eps1/eps1 < 0 && -2*Elplus*p1p3/eps1-p1p3*p1p3/eps1/eps1-m3*m3 < 0 && -2*Elminus*p1p4/eps1-p1p4*p1p4/eps1/eps1-m4*m4 < 0){
        qy = 0.0;
	
	    plplusy = 0.0;
        plplusx = 0.0;
	
	    plminusy = 0.0;
        plminusx = 0.0;
	
        pnuouty = 0.0;
        pnuoutx = 0.0;
    }
    
    
    // nuclear recoil 4-momentum
    
        Eprime = M + Enuin - Enuout - Elplus - Elminus;
        Pprimex = - pnuoutx - plplusx - plminusx;
        Pprimey = - pnuouty - plplusy - plminusy;
        Pprimez = pnuinz - pnuoutz - plplusz - plminusz;
    
    return;
}


//*****************************************************************
// squared matrix elements for neutrino and anti-neutrino tridents
//*****************************************************************

double SquaredMatrixElementPLP(double GFV, double GFA){

    double GFA2, GFV2, GFAGFV, result;
    
    GFA2 = GFA*GFA;
    GFV2 = GFV*GFV;
    GFAGFV = GFA*GFV;

    result = 4*((64*GFA2*m3*m4*p1p2*p3P*p3P)/D32 - 
                (64*GFV2*m3*m4*p1p2*p3P*p3P)/D32 + 
                (64*GFA2*p1p4*p2p3*p3P*p3P)/D32 + 
                (128*GFAGFV*p1p4*p2p3*p3P*p3P)/D32 + 
                (64*GFV2*p1p4*p2p3*p3P*p3P)/D32 + 
                (64*GFA2*p1p3*p2p4*p3P*p3P)/D32 - 
                (128*GFAGFV*p1p3*p2p4*p3P*p3P)/D32 + 
                (64*GFV2*p1p3*p2p4*p3P*p3P)/D32 - 
                (128*GFA2*m3*m4*p1p2*p3P*p4P)/D3D4 + 
                (128*GFV2*m3*m4*p1p2*p3P*p4P)/D3D4 - 
                (128*GFA2*p1p4*p2p3*p3P*p4P)/D3D4 - 
                (256*GFAGFV*p1p4*p2p3*p3P*p4P)/D3D4 - 
                (128*GFV2*p1p4*p2p3*p3P*p4P)/D3D4 - 
                (128*GFA2*p1p3*p2p4*p3P*p4P)/D3D4 + 
                (256*GFAGFV*p1p3*p2p4*p3P*p4P)/D3D4 - 
                (128*GFV2*p1p3*p2p4*p3P*p4P)/D3D4 + 
                (64*GFA2*m3*m4*p1p2*p4P*p4P)/D42 - 
                (64*GFV2*m3*m4*p1p2*p4P*p4P)/D42 + 
                (64*GFA2*p1p4*p2p3*p4P*p4P)/D42 + 
                (128*GFAGFV*p1p4*p2p3*p4P*p4P)/D42 + 
                (64*GFV2*p1p4*p2p3*p4P*p4P)/D42 + 
                (64*GFA2*p1p3*p2p4*p4P*p4P)/D42 - 
                (128*GFAGFV*p1p3*p2p4*p4P*p4P)/D42 + 
                (64*GFV2*p1p3*p2p4*p4P*p4P)/D42 - 
                (16*GFA2*M2*m3*m4*p1p2*q2)/D32 - 
                (16*GFA2*M2*m3*m4*p1p2*q2)/D42 + 
                (32*GFA2*M2*m3*m4*p1p2*q2)/D3D4 + 
                (16*GFV2*M2*m3*m4*p1p2*q2)/D32 + 
                (16*GFV2*M2*m3*m4*p1p2*q2)/D42 - 
                (32*GFV2*M2*m3*m4*p1p2*q2)/D3D4 + 
                (64*GFA2*m3*m4*p1P*p2P*q2)/D3D4 - 
                (64*GFV2*m3*m4*p1P*p2P*q2)/D3D4 - 
                (16*GFA2*M2*p1p4*p2p3*q2)/D32 - 
                (16*GFA2*M2*p1p4*p2p3*q2)/D42 - 
                (32*GFA2*M2*p1p4*p2p3*q2)/D3D4 - 
                (32*GFAGFV*M2*p1p4*p2p3*q2)/D32 - 
                (32*GFAGFV*M2*p1p4*p2p3*q2)/D42 + 
                (64*GFAGFV*M2*p1p4*p2p3*q2)/D3D4 - 
                (16*GFV2*M2*p1p4*p2p3*q2)/D32 - 
                (16*GFV2*M2*p1p4*p2p3*q2)/D42 - 
                (32*GFV2*M2*p1p4*p2p3*q2)/D3D4 - 
                (16*GFA2*M2*p1p3*p2p4*q2)/D32 - 
                (16*GFA2*M2*p1p3*p2p4*q2)/D42 - 
                (32*GFA2*M2*p1p3*p2p4*q2)/D3D4 + 
                (32*GFAGFV*M2*p1p3*p2p4*q2)/D32 + 
                (32*GFAGFV*M2*p1p3*p2p4*q2)/D42 - 
                (64*GFAGFV*M2*p1p3*p2p4*q2)/D3D4 - 
                (16*GFV2*M2*p1p3*p2p4*q2)/D32 - 
                (16*GFV2*M2*p1p3*p2p4*q2)/D42 - 
                (32*GFV2*M2*p1p3*p2p4*q2)/D3D4 - 
                (32*GFA2*p1p4*p2P*p3P*q2)/D32 - 
                (32*GFA2*p1p4*p2P*p3P*q2)/D3D4 - 
                (64*GFAGFV*p1p4*p2P*p3P*q2)/D32 + 
                (64*GFAGFV*p1p4*p2P*p3P*q2)/D3D4 - 
                (32*GFV2*p1p4*p2P*p3P*q2)/D32 - 
                (32*GFV2*p1p4*p2P*p3P*q2)/D3D4 - 
                (32*GFA2*p1P*p2p4*p3P*q2)/D32 - 
                (32*GFA2*p1P*p2p4*p3P*q2)/D3D4 + 
                (64*GFAGFV*p1P*p2p4*p3P*q2)/D32 - 
                (64*GFAGFV*p1P*p2p4*p3P*q2)/D3D4 - 
                (32*GFV2*p1P*p2p4*p3P*q2)/D32 - 
                (32*GFV2*p1P*p2p4*p3P*q2)/D3D4 + 
                (64*GFA2*M2*p1p2*p3p4*q2)/D3D4 + 
                (64*GFV2*M2*p1p2*p3p4*q2)/D3D4 + 
                (64*GFA2*p1P*p2P*p3p4*q2)/D3D4 + 
                (64*GFV2*p1P*p2P*p3p4*q2)/D3D4 - 
                (32*GFA2*p1p3*p2P*p4P*q2)/D42 - 
                (32*GFA2*p1p3*p2P*p4P*q2)/D3D4 + 
                (64*GFAGFV*p1p3*p2P*p4P*q2)/D42 - 
                (64*GFAGFV*p1p3*p2P*p4P*q2)/D3D4 - 
                (32*GFV2*p1p3*p2P*p4P*q2)/D42 -
                (32*GFV2*p1p3*p2P*p4P*q2)/D3D4 - 
                (32*GFA2*p1P*p2p3*p4P*q2)/D42 - 
                (32*GFA2*p1P*p2p3*p4P*q2)/D3D4 - 
                (64*GFAGFV*p1P*p2p3*p4P*q2)/D42 + 
                (64*GFAGFV*p1P*p2p3*p4P*q2)/D3D4 - 
                (32*GFV2*p1P*p2p3*p4P*q2)/D42 - 
                (32*GFV2*p1P*p2p3*p4P*q2)/D3D4 + 
                (64*GFA2*p1p2*p3P*p4P*q2)/D3D4 + 
                (64*GFV2*p1p2*p3P*p4P*q2)/D3D4 - 
                (64*GFA2*m3*m4*p1p2*p3P*qP)/D32 + 
                (64*GFA2*m3*m4*p1p2*p3P*qP)/D3D4 + 
                (64*GFV2*m3*m4*p1p2*p3P*qP)/D32 - 
                (64*GFV2*m3*m4*p1p2*p3P*qP)/D3D4 - 
                (64*GFA2*p1p4*p2p3*p3P*qP)/D32 + 
                (64*GFA2*p1p4*p2p3*p3P*qP)/D3D4 - 
                (128*GFAGFV*p1p4*p2p3*p3P*qP)/D32 + 
                (128*GFAGFV*p1p4*p2p3*p3P*qP)/D3D4 - 
                (64*GFV2*p1p4*p2p3*p3P*qP)/D32 + 
                (64*GFV2*p1p4*p2p3*p3P*qP)/D3D4 - 
                (64*GFA2*p1p3*p2p4*p3P*qP)/D32 + 
                (64*GFA2*p1p3*p2p4*p3P*qP)/D3D4 + 
                (128*GFAGFV*p1p3*p2p4*p3P*qP)/D32 - 
                (128*GFAGFV*p1p3*p2p4*p3P*qP)/D3D4 - 
                (64*GFV2*p1p3*p2p4*p3P*qP)/D32 + 
                (64*GFV2*p1p3*p2p4*p3P*qP)/D3D4 - 
                (64*GFA2*m3*m4*p1p2*p4P*qP)/D42 + 
                (64*GFA2*m3*m4*p1p2*p4P*qP)/D3D4 + 
                (64*GFV2*m3*m4*p1p2*p4P*qP)/D42 - 
                (64*GFV2*m3*m4*p1p2*p4P*qP)/D3D4 - 
                (64*GFA2*p1p4*p2p3*p4P*qP)/D42 + 
                (64*GFA2*p1p4*p2p3*p4P*qP)/D3D4 - 
                (128*GFAGFV*p1p4*p2p3*p4P*qP)/D42 + 
                (128*GFAGFV*p1p4*p2p3*p4P*qP)/D3D4 - 
                (64*GFV2*p1p4*p2p3*p4P*qP)/D42 + 
                (64*GFV2*p1p4*p2p3*p4P*qP)/D3D4 - 
                (64*GFA2*p1p3*p2p4*p4P*qP)/D42 + 
                (64*GFA2*p1p3*p2p4*p4P*qP)/D3D4 + 
                (128*GFAGFV*p1p3*p2p4*p4P*qP)/D42 - 
                (128*GFAGFV*p1p3*p2p4*p4P*qP)/D3D4 - 
                (64*GFV2*p1p3*p2p4*p4P*qP)/D42 + 
                (64*GFV2*p1p3*p2p4*p4P*qP)/D3D4 - 
                (64*GFA2*p1p4*p2p3*qP*qP)/D3D4 - 
                (64*GFV2*p1p4*p2p3*qP*qP)/D3D4 - 
                (64*GFA2*p1p3*p2p4*qP*qP)/D3D4 - 
                (64*GFV2*p1p3*p2p4*qP*qP)/D3D4 + 
                (64*GFA2*p1p2*p3p4*qP*qP)/D3D4 + 
                (64*GFV2*p1p2*p3p4*qP*qP)/D3D4 - 
                (64*GFA2*p2p4*p3P*p3P*qp1)/D32 + 
                (128*GFAGFV*p2p4*p3P*p3P*qp1)/D32 - 
                (64*GFV2*p2p4*p3P*p3P*qp1)/D32 + 
                (64*GFA2*p2p3*p3P*p4P*qp1)/D3D4 + 
                (128*GFAGFV*p2p3*p3P*p4P*qp1)/D3D4 + 
                (64*GFV2*p2p3*p3P*p4P*qp1)/D3D4 + 
                (64*GFA2*p2p4*p3P*p4P*qp1)/D3D4 - 
                (128*GFAGFV*p2p4*p3P*p4P*qp1)/D3D4 + 
                (64*GFV2*p2p4*p3P*p4P*qp1)/D3D4 - 
                (64*GFA2*p2p3*p4P*p4P*qp1)/D42 - 
                (128*GFAGFV*p2p3*p4P*p4P*qp1)/D42 - 
                (64*GFV2*p2p3*p4P*p4P*qp1)/D42 - 
                (64*GFA2*m3*m4*p2P*qP*qp1)/D3D4 + 
                (64*GFV2*m3*m4*p2P*qP*qp1)/D3D4 + 
                (64*GFA2*p2p4*p3P*qP*qp1)/D32 - 
                (128*GFAGFV*p2p4*p3P*qP*qp1)/D32 + 
                (128*GFAGFV*p2p4*p3P*qP*qp1)/D3D4 + 
                (64*GFV2*p2p4*p3P*qP*qp1)/D32 - 
                (64*GFA2*p2P*p3p4*qP*qp1)/D3D4 - 
                (64*GFV2*p2P*p3p4*qP*qp1)/D3D4 + 
                (64*GFA2*p2p3*p4P*qP*qp1)/D42 + 
                (128*GFAGFV*p2p3*p4P*qP*qp1)/D42 - 
                (128*GFAGFV*p2p3*p4P*qP*qp1)/D3D4 + 
                (64*GFV2*p2p3*p4P*qP*qp1)/D42 - 
                (64*GFA2*p1p4*p3P*p3P*qp2)/D32 - 
                (128*GFAGFV*p1p4*p3P*p3P*qp2)/D32 - 
                (64*GFV2*p1p4*p3P*p3P*qp2)/D32 + 
                (64*GFA2*p1p3*p3P*p4P*qp2)/D3D4 - 
                (128*GFAGFV*p1p3*p3P*p4P*qp2)/D3D4 + 
                (64*GFV2*p1p3*p3P*p4P*qp2)/D3D4 + 
                (64*GFA2*p1p4*p3P*p4P*qp2)/D3D4 + 
                (128*GFAGFV*p1p4*p3P*p4P*qp2)/D3D4 + 
                (64*GFV2*p1p4*p3P*p4P*qp2)/D3D4 - 
                (64*GFA2*p1p3*p4P*p4P*qp2)/D42 + 
                (128*GFAGFV*p1p3*p4P*p4P*qp2)/D42 - 
                (64*GFV2*p1p3*p4P*p4P*qp2)/D42 - 
                (64*GFA2*m3*m4*p1P*qP*qp2)/D3D4 + 
                (64*GFV2*m3*m4*p1P*qP*qp2)/D3D4 + 
                (64*GFA2*p1p4*p3P*qP*qp2)/D32 + 
                (128*GFAGFV*p1p4*p3P*qP*qp2)/D32 - 
                (128*GFAGFV*p1p4*p3P*qP*qp2)/D3D4 + 
                (64*GFV2*p1p4*p3P*qP*qp2)/D32 - 
                (64*GFA2*p1P*p3p4*qP*qp2)/D3D4 - 
                (64*GFV2*p1P*p3p4*qP*qp2)/D3D4 + 
                (64*GFA2*p1p3*p4P*qP*qp2)/D42 - 
                (128*GFAGFV*p1p3*p4P*qP*qp2)/D42 + 
                (128*GFAGFV*p1p3*p4P*qP*qp2)/D3D4 + 
                (64*GFV2*p1p3*p4P*qP*qp2)/D42 - 
                (64*GFA2*M2*m3*m4*qp1*qp2)/D3D4 + 
                (64*GFV2*M2*m3*m4*qp1*qp2)/D3D4 - 
                (64*GFA2*M2*p3p4*qp1*qp2)/D3D4 - 
                (64*GFV2*M2*p3p4*qp1*qp2)/D3D4 - 
                (128*GFA2*p3P*p4P*qp1*qp2)/D3D4 - 
                (128*GFV2*p3P*p4P*qp1*qp2)/D3D4 + 
                (64*GFA2*p1p4*p2P*p3P*qp3)/D32 + 
                (128*GFAGFV*p1p4*p2P*p3P*qp3)/D32 + 
                (64*GFV2*p1p4*p2P*p3P*qp3)/D32 + 
                (64*GFA2*p1P*p2p4*p3P*qp3)/D32 - 
                (128*GFAGFV*p1P*p2p4*p3P*qp3)/D32 + 
                (64*GFV2*p1P*p2p4*p3P*qp3)/D32 - 
                (64*GFA2*p1p4*p2P*p4P*qp3)/D3D4 - 
                (128*GFAGFV*p1p4*p2P*p4P*qp3)/D3D4 - 
                (64*GFV2*p1p4*p2P*p4P*qp3)/D3D4 - 
                (64*GFA2*p1P*p2p4*p4P*qp3)/D3D4 + 
                (128*GFAGFV*p1P*p2p4*p4P*qp3)/D3D4 - 
                (64*GFV2*p1P*p2p4*p4P*qp3)/D3D4 + 
                (64*GFA2*p1p4*p2P*qP*qp3)/D3D4 + 
                (64*GFV2*p1p4*p2P*qP*qp3)/D3D4 + 
                (64*GFA2*p1P*p2p4*qP*qp3)/D3D4 + 
                (64*GFV2*p1P*p2p4*qP*qp3)/D3D4 - 
                (64*GFA2*p1p2*p4P*qP*qp3)/D3D4 - 
                (64*GFV2*p1p2*p4P*qP*qp3)/D3D4 + 
                (32*GFA2*M2*p2p4*qp1*qp3)/D32 + 
                (32*GFA2*M2*p2p4*qp1*qp3)/D3D4 - 
                (64*GFAGFV*M2*p2p4*qp1*qp3)/D32 + 
                (64*GFAGFV*M2*p2p4*qp1*qp3)/D3D4 + 
                (32*GFV2*M2*p2p4*qp1*qp3)/D32 + 
                (32*GFV2*M2*p2p4*qp1*qp3)/D3D4 + 
                (64*GFA2*p2P*p4P*qp1*qp3)/D3D4 + 
                (128*GFAGFV*p2P*p4P*qp1*qp3)/D3D4 + 
                (64*GFV2*p2P*p4P*qp1*qp3)/D3D4 + 
                (32*GFA2*M2*p1p4*qp2*qp3)/D32 + 
                (32*GFA2*M2*p1p4*qp2*qp3)/D3D4 + 
                (64*GFAGFV*M2*p1p4*qp2*qp3)/D32 - 
                (64*GFAGFV*M2*p1p4*qp2*qp3)/D3D4 + 
                (32*GFV2*M2*p1p4*qp2*qp3)/D32 + 
                (32*GFV2*M2*p1p4*qp2*qp3)/D3D4 + 
                (64*GFA2*p1P*p4P*qp2*qp3)/D3D4 - 
                (128*GFAGFV*p1P*p4P*qp2*qp3)/D3D4 + 
                (64*GFV2*p1P*p4P*qp2*qp3)/D3D4 - 
                (64*GFA2*p1p3*p2P*p3P*qp4)/D3D4 + 
                (128*GFAGFV*p1p3*p2P*p3P*qp4)/D3D4 - 
                (64*GFV2*p1p3*p2P*p3P*qp4)/D3D4 - 
                (64*GFA2*p1P*p2p3*p3P*qp4)/D3D4 - 
                (128*GFAGFV*p1P*p2p3*p3P*qp4)/D3D4 - 
                (64*GFV2*p1P*p2p3*p3P*qp4)/D3D4 + 
                (64*GFA2*p1p3*p2P*p4P*qp4)/D42 - 
                (128*GFAGFV*p1p3*p2P*p4P*qp4)/D42 + 
                (64*GFV2*p1p3*p2P*p4P*qp4)/D42 + 
                (64*GFA2*p1P*p2p3*p4P*qp4)/D42 + 
                (128*GFAGFV*p1P*p2p3*p4P*qp4)/D42 + 
                (64*GFV2*p1P*p2p3*p4P*qp4)/D42 + 
                (64*GFA2*p1p3*p2P*qP*qp4)/D3D4 + 
                (64*GFV2*p1p3*p2P*qP*qp4)/D3D4 + 
                (64*GFA2*p1P*p2p3*qP*qp4)/D3D4 + 
                (64*GFV2*p1P*p2p3*qP*qp4)/D3D4 - 
                (64*GFA2*p1p2*p3P*qP*qp4)/D3D4 - 
                (64*GFV2*p1p2*p3P*qP*qp4)/D3D4 + 
                (32*GFA2*M2*p2p3*qp1*qp4)/D42 + 
                (32*GFA2*M2*p2p3*qp1*qp4)/D3D4 + 
                (64*GFAGFV*M2*p2p3*qp1*qp4)/D42 - 
                (64*GFAGFV*M2*p2p3*qp1*qp4)/D3D4 + 
                (32*GFV2*M2*p2p3*qp1*qp4)/D42 + 
                (32*GFV2*M2*p2p3*qp1*qp4)/D3D4 + 
                (64*GFA2*p2P*p3P*qp1*qp4)/D3D4 - 
                (128*GFAGFV*p2P*p3P*qp1*qp4)/D3D4 + 
                (64*GFV2*p2P*p3P*qp1*qp4)/D3D4 + 
                (32*GFA2*M2*p1p3*qp2*qp4)/D42 + 
                (32*GFA2*M2*p1p3*qp2*qp4)/D3D4 - 
                (64*GFAGFV*M2*p1p3*qp2*qp4)/D42 + 
                (64*GFAGFV*M2*p1p3*qp2*qp4)/D3D4 + 
                (32*GFV2*M2*p1p3*qp2*qp4)/D42 + 
                (32*GFV2*M2*p1p3*qp2*qp4)/D3D4 + 
                (64*GFA2*p1P*p3P*qp2*qp4)/D3D4 + 
                (128*GFAGFV*p1P*p3P*qp2*qp4)/D3D4 + 
                (64*GFV2*p1P*p3P*qp2*qp4)/D3D4 - 
                (64*GFA2*M2*p1p2*qp3*qp4)/D3D4 - 
                (64*GFV2*M2*p1p2*qp3*qp4)/D3D4 - 
                (128*GFA2*p1P*p2P*qp3*qp4)/D3D4 - 
                (128*GFV2*p1P*p2P*qp3*qp4)/D3D4);

    return result;
}


double SquaredMatrixElementPLPanti(double GFV, double GFA){

    double GFA2, GFV2, GFAGFV, result;
    
    GFA2 = GFA*GFA;
    GFV2 = GFV*GFV;
    GFAGFV = GFA*GFV;

    result = 4*((64*GFA2*m3*m4*p1p2*p3P*p3P)/D32 - 
                (64*GFV2*m3*m4*p1p2*p3P*p3P)/D32 + 
                (64*GFA2*p1p4*p2p3*p3P*p3P)/D32 - 
                (128*GFAGFV*p1p4*p2p3*p3P*p3P)/D32 + 
                (64*GFV2*p1p4*p2p3*p3P*p3P)/D32 + 
                (64*GFA2*p1p3*p2p4*p3P*p3P)/D32 + 
                (128*GFAGFV*p1p3*p2p4*p3P*p3P)/D32 + 
                (64*GFV2*p1p3*p2p4*p3P*p3P)/D32 - 
                (128*GFA2*m3*m4*p1p2*p3P*p4P)/D3D4 + 
                (128*GFV2*m3*m4*p1p2*p3P*p4P)/D3D4 - 
                (128*GFA2*p1p4*p2p3*p3P*p4P)/D3D4 + 
                (256*GFAGFV*p1p4*p2p3*p3P*p4P)/D3D4 - 
                (128*GFV2*p1p4*p2p3*p3P*p4P)/D3D4 - 
                (128*GFA2*p1p3*p2p4*p3P*p4P)/D3D4 - 
                (256*GFAGFV*p1p3*p2p4*p3P*p4P)/D3D4 - 
                (128*GFV2*p1p3*p2p4*p3P*p4P)/D3D4 + 
                (64*GFA2*m3*m4*p1p2*p4P*p4P)/D42 - 
                (64*GFV2*m3*m4*p1p2*p4P*p4P)/D42 + 
                (64*GFA2*p1p4*p2p3*p4P*p4P)/D42 - 
                (128*GFAGFV*p1p4*p2p3*p4P*p4P)/D42 + 
                (64*GFV2*p1p4*p2p3*p4P*p4P)/D42 + 
                (64*GFA2*p1p3*p2p4*p4P*p4P)/D42 + 
                (128*GFAGFV*p1p3*p2p4*p4P*p4P)/D42 + 
                (64*GFV2*p1p3*p2p4*p4P*p4P)/D42 - 
                (16*GFA2*M2*m3*m4*p1p2*q2)/D32 - 
                (16*GFA2*M2*m3*m4*p1p2*q2)/D42 + 
                (32*GFA2*M2*m3*m4*p1p2*q2)/D3D4 + 
                (16*GFV2*M2*m3*m4*p1p2*q2)/D32 + 
                (16*GFV2*M2*m3*m4*p1p2*q2)/D42 - 
                (32*GFV2*M2*m3*m4*p1p2*q2)/D3D4 + 
                (64*GFA2*m3*m4*p1P*p2P*q2)/D3D4 - 
                (64*GFV2*m3*m4*p1P*p2P*q2)/D3D4 - 
                (16*GFA2*M2*p1p4*p2p3*q2)/D32 - 
                (16*GFA2*M2*p1p4*p2p3*q2)/D42 - 
                (32*GFA2*M2*p1p4*p2p3*q2)/D3D4 + 
                (32*GFAGFV*M2*p1p4*p2p3*q2)/D32 + 
                (32*GFAGFV*M2*p1p4*p2p3*q2)/D42 - 
                (64*GFAGFV*M2*p1p4*p2p3*q2)/D3D4 - 
                (16*GFV2*M2*p1p4*p2p3*q2)/D32 - 
                (16*GFV2*M2*p1p4*p2p3*q2)/D42 - 
                (32*GFV2*M2*p1p4*p2p3*q2)/D3D4 - 
                (16*GFA2*M2*p1p3*p2p4*q2)/D32 - 
                (16*GFA2*M2*p1p3*p2p4*q2)/D42 - 
                (32*GFA2*M2*p1p3*p2p4*q2)/D3D4 - 
                (32*GFAGFV*M2*p1p3*p2p4*q2)/D32 - 
                (32*GFAGFV*M2*p1p3*p2p4*q2)/D42 + 
                (64*GFAGFV*M2*p1p3*p2p4*q2)/D3D4 - 
                (16*GFV2*M2*p1p3*p2p4*q2)/D32 - 
                (16*GFV2*M2*p1p3*p2p4*q2)/D42 - 
                (32*GFV2*M2*p1p3*p2p4*q2)/D3D4 - 
                (32*GFA2*p1p4*p2P*p3P*q2)/D32 - 
                (32*GFA2*p1p4*p2P*p3P*q2)/D3D4 + 
                (64*GFAGFV*p1p4*p2P*p3P*q2)/D32 - 
                (64*GFAGFV*p1p4*p2P*p3P*q2)/D3D4 - 
                (32*GFV2*p1p4*p2P*p3P*q2)/D32 - 
                (32*GFV2*p1p4*p2P*p3P*q2)/D3D4 - 
                (32*GFA2*p1P*p2p4*p3P*q2)/D32 - 
                (32*GFA2*p1P*p2p4*p3P*q2)/D3D4 - 
                (64*GFAGFV*p1P*p2p4*p3P*q2)/D32 + 
                (64*GFAGFV*p1P*p2p4*p3P*q2)/D3D4 - 
                (32*GFV2*p1P*p2p4*p3P*q2)/D32 - 
                (32*GFV2*p1P*p2p4*p3P*q2)/D3D4 + 
                (64*GFA2*M2*p1p2*p3p4*q2)/D3D4 + 
                (64*GFV2*M2*p1p2*p3p4*q2)/D3D4 + 
                (64*GFA2*p1P*p2P*p3p4*q2)/D3D4 + 
                (64*GFV2*p1P*p2P*p3p4*q2)/D3D4 - 
                (32*GFA2*p1p3*p2P*p4P*q2)/D42 - 
                (32*GFA2*p1p3*p2P*p4P*q2)/D3D4 - 
                (64*GFAGFV*p1p3*p2P*p4P*q2)/D42 + 
                (64*GFAGFV*p1p3*p2P*p4P*q2)/D3D4 - 
                (32*GFV2*p1p3*p2P*p4P*q2)/D42 - 
                (32*GFV2*p1p3*p2P*p4P*q2)/D3D4 - 
                (32*GFA2*p1P*p2p3*p4P*q2)/D42 - 
                (32*GFA2*p1P*p2p3*p4P*q2)/D3D4 + 
                (64*GFAGFV*p1P*p2p3*p4P*q2)/D42 - 
                (64*GFAGFV*p1P*p2p3*p4P*q2)/D3D4 - 
                (32*GFV2*p1P*p2p3*p4P*q2)/D42 - 
                (32*GFV2*p1P*p2p3*p4P*q2)/D3D4 + 
                (64*GFA2*p1p2*p3P*p4P*q2)/D3D4 + 
                (64*GFV2*p1p2*p3P*p4P*q2)/D3D4 - 
                (64*GFA2*m3*m4*p1p2*p3P*qP)/D32 + 
                (64*GFA2*m3*m4*p1p2*p3P*qP)/D3D4 + 
                (64*GFV2*m3*m4*p1p2*p3P*qP)/D32 - 
                (64*GFV2*m3*m4*p1p2*p3P*qP)/D3D4 - 
                (64*GFA2*p1p4*p2p3*p3P*qP)/D32 + 
                (64*GFA2*p1p4*p2p3*p3P*qP)/D3D4 + 
                (128*GFAGFV*p1p4*p2p3*p3P*qP)/D32 - 
                (128*GFAGFV*p1p4*p2p3*p3P*qP)/D3D4 - 
                (64*GFV2*p1p4*p2p3*p3P*qP)/D32 + 
                (64*GFV2*p1p4*p2p3*p3P*qP)/D3D4 - 
                (64*GFA2*p1p3*p2p4*p3P*qP)/D32 + 
                (64*GFA2*p1p3*p2p4*p3P*qP)/D3D4 - 
                (128*GFAGFV*p1p3*p2p4*p3P*qP)/D32 + 
                (128*GFAGFV*p1p3*p2p4*p3P*qP)/D3D4 - 
                (64*GFV2*p1p3*p2p4*p3P*qP)/D32 + 
                (64*GFV2*p1p3*p2p4*p3P*qP)/D3D4 - 
                (64*GFA2*m3*m4*p1p2*p4P*qP)/D42 + 
                (64*GFA2*m3*m4*p1p2*p4P*qP)/D3D4 + 
                (64*GFV2*m3*m4*p1p2*p4P*qP)/D42 - 
                (64*GFV2*m3*m4*p1p2*p4P*qP)/D3D4 - 
                (64*GFA2*p1p4*p2p3*p4P*qP)/D42 + 
                (64*GFA2*p1p4*p2p3*p4P*qP)/D3D4 + 
                (128*GFAGFV*p1p4*p2p3*p4P*qP)/D42 - 
                (128*GFAGFV*p1p4*p2p3*p4P*qP)/D3D4 - 
                (64*GFV2*p1p4*p2p3*p4P*qP)/D42 + 
                (64*GFV2*p1p4*p2p3*p4P*qP)/D3D4 - 
                (64*GFA2*p1p3*p2p4*p4P*qP)/D42 + 
                (64*GFA2*p1p3*p2p4*p4P*qP)/D3D4 - 
                (128*GFAGFV*p1p3*p2p4*p4P*qP)/D42 + 
                (128*GFAGFV*p1p3*p2p4*p4P*qP)/D3D4 - 
                (64*GFV2*p1p3*p2p4*p4P*qP)/D42 + 
                (64*GFV2*p1p3*p2p4*p4P*qP)/D3D4 - 
                (64*GFA2*p1p4*p2p3*qP*qP)/D3D4 - 
                (64*GFV2*p1p4*p2p3*qP*qP)/D3D4 - 
                (64*GFA2*p1p3*p2p4*qP*qP)/D3D4 - 
                (64*GFV2*p1p3*p2p4*qP*qP)/D3D4 + 
                (64*GFA2*p1p2*p3p4*qP*qP)/D3D4 + 
                (64*GFV2*p1p2*p3p4*qP*qP)/D3D4 - 
                (64*GFA2*p2p4*p3P*p3P*qp1)/D32 - 
                (128*GFAGFV*p2p4*p3P*p3P*qp1)/D32 - 
                (64*GFV2*p2p4*p3P*p3P*qp1)/D32 + 
                (64*GFA2*p2p3*p3P*p4P*qp1)/D3D4 - 
                (128*GFAGFV*p2p3*p3P*p4P*qp1)/D3D4 + 
                (64*GFV2*p2p3*p3P*p4P*qp1)/D3D4 + 
                (64*GFA2*p2p4*p3P*p4P*qp1)/D3D4 + 
                (128*GFAGFV*p2p4*p3P*p4P*qp1)/D3D4 + 
                (64*GFV2*p2p4*p3P*p4P*qp1)/D3D4 - 
                (64*GFA2*p2p3*p4P*p4P*qp1)/D42 + 
                (128*GFAGFV*p2p3*p4P*p4P*qp1)/D42 - 
                (64*GFV2*p2p3*p4P*p4P*qp1)/D42 - 
                (64*GFA2*m3*m4*p2P*qP*qp1)/D3D4 + 
                (64*GFV2*m3*m4*p2P*qP*qp1)/D3D4 + 
                (64*GFA2*p2p4*p3P*qP*qp1)/D32 + 
                (128*GFAGFV*p2p4*p3P*qP*qp1)/D32 - 
                (128*GFAGFV*p2p4*p3P*qP*qp1)/D3D4 + 
                (64*GFV2*p2p4*p3P*qP*qp1)/D32 - 
                (64*GFA2*p2P*p3p4*qP*qp1)/D3D4 - 
                (64*GFV2*p2P*p3p4*qP*qp1)/D3D4 + 
                (64*GFA2*p2p3*p4P*qP*qp1)/D42 - 
                (128*GFAGFV*p2p3*p4P*qP*qp1)/D42 + 
                (128*GFAGFV*p2p3*p4P*qP*qp1)/D3D4 + 
                (64*GFV2*p2p3*p4P*qP*qp1)/D42 - 
                (64*GFA2*p1p4*p3P*p3P*qp2)/D32 + 
                (128*GFAGFV*p1p4*p3P*p3P*qp2)/D32 - 
                (64*GFV2*p1p4*p3P*p3P*qp2)/D32 + 
                (64*GFA2*p1p3*p3P*p4P*qp2)/D3D4 + 
                (128*GFAGFV*p1p3*p3P*p4P*qp2)/D3D4 + 
                (64*GFV2*p1p3*p3P*p4P*qp2)/D3D4 + 
                (64*GFA2*p1p4*p3P*p4P*qp2)/D3D4 - 
                (128*GFAGFV*p1p4*p3P*p4P*qp2)/D3D4 + 
                (64*GFV2*p1p4*p3P*p4P*qp2)/D3D4 - 
                (64*GFA2*p1p3*p4P*p4P*qp2)/D42 - 
                (128*GFAGFV*p1p3*p4P*p4P*qp2)/D42 - 
                (64*GFV2*p1p3*p4P*p4P*qp2)/D42 - 
                (64*GFA2*m3*m4*p1P*qP*qp2)/D3D4 + 
                (64*GFV2*m3*m4*p1P*qP*qp2)/D3D4 + 
                (64*GFA2*p1p4*p3P*qP*qp2)/D32 - 
                (128*GFAGFV*p1p4*p3P*qP*qp2)/D32 + 
                (128*GFAGFV*p1p4*p3P*qP*qp2)/D3D4 + 
                (64*GFV2*p1p4*p3P*qP*qp2)/D32 - 
                (64*GFA2*p1P*p3p4*qP*qp2)/D3D4 - 
                (64*GFV2*p1P*p3p4*qP*qp2)/D3D4 + 
                (64*GFA2*p1p3*p4P*qP*qp2)/D42 + 
                (128*GFAGFV*p1p3*p4P*qP*qp2)/D42 - 
                (128*GFAGFV*p1p3*p4P*qP*qp2)/D3D4 + 
                (64*GFV2*p1p3*p4P*qP*qp2)/D42 - 
                (64*GFA2*M2*m3*m4*qp1*qp2)/D3D4 + 
                (64*GFV2*M2*m3*m4*qp1*qp2)/D3D4 - 
                (64*GFA2*M2*p3p4*qp1*qp2)/D3D4 - 
                (64*GFV2*M2*p3p4*qp1*qp2)/D3D4 - 
                (128*GFA2*p3P*p4P*qp1*qp2)/D3D4 - 
                (128*GFV2*p3P*p4P*qp1*qp2)/D3D4 + 
                (64*GFA2*p1p4*p2P*p3P*qp3)/D32 - 
                (128*GFAGFV*p1p4*p2P*p3P*qp3)/D32 + 
                (64*GFV2*p1p4*p2P*p3P*qp3)/D32 + 
                (64*GFA2*p1P*p2p4*p3P*qp3)/D32 + 
                (128*GFAGFV*p1P*p2p4*p3P*qp3)/D32 + 
                (64*GFV2*p1P*p2p4*p3P*qp3)/D32 - 
                (64*GFA2*p1p4*p2P*p4P*qp3)/D3D4 + 
                (128*GFAGFV*p1p4*p2P*p4P*qp3)/D3D4 - 
                (64*GFV2*p1p4*p2P*p4P*qp3)/D3D4 - 
                (64*GFA2*p1P*p2p4*p4P*qp3)/D3D4 - 
                (128*GFAGFV*p1P*p2p4*p4P*qp3)/D3D4 - 
                (64*GFV2*p1P*p2p4*p4P*qp3)/D3D4 + 
                (64*GFA2*p1p4*p2P*qP*qp3)/D3D4 + 
                (64*GFV2*p1p4*p2P*qP*qp3)/D3D4 + 
                (64*GFA2*p1P*p2p4*qP*qp3)/D3D4 + 
                (64*GFV2*p1P*p2p4*qP*qp3)/D3D4 - 
                (64*GFA2*p1p2*p4P*qP*qp3)/D3D4 - 
                (64*GFV2*p1p2*p4P*qP*qp3)/D3D4 + 
                (32*GFA2*M2*p2p4*qp1*qp3)/D32 + 
                (32*GFA2*M2*p2p4*qp1*qp3)/D3D4 + 
                (64*GFAGFV*M2*p2p4*qp1*qp3)/D32 - 
                (64*GFAGFV*M2*p2p4*qp1*qp3)/D3D4 + 
                (32*GFV2*M2*p2p4*qp1*qp3)/D32 + 
                (32*GFV2*M2*p2p4*qp1*qp3)/D3D4 + 
                (64*GFA2*p2P*p4P*qp1*qp3)/D3D4 - 
                (128*GFAGFV*p2P*p4P*qp1*qp3)/D3D4 + 
                (64*GFV2*p2P*p4P*qp1*qp3)/D3D4 + 
                (32*GFA2*M2*p1p4*qp2*qp3)/D32 + 
                (32*GFA2*M2*p1p4*qp2*qp3)/D3D4 - 
                (64*GFAGFV*M2*p1p4*qp2*qp3)/D32 + 
                (64*GFAGFV*M2*p1p4*qp2*qp3)/D3D4 + 
                (32*GFV2*M2*p1p4*qp2*qp3)/D32 + 
                (32*GFV2*M2*p1p4*qp2*qp3)/D3D4 + 
                (64*GFA2*p1P*p4P*qp2*qp3)/D3D4 + 
                (128*GFAGFV*p1P*p4P*qp2*qp3)/D3D4 + 
                (64*GFV2*p1P*p4P*qp2*qp3)/D3D4 - 
                (64*GFA2*p1p3*p2P*p3P*qp4)/D3D4 - 
                (128*GFAGFV*p1p3*p2P*p3P*qp4)/D3D4 - 
                (64*GFV2*p1p3*p2P*p3P*qp4)/D3D4 - 
                (64*GFA2*p1P*p2p3*p3P*qp4)/D3D4 + 
                (128*GFAGFV*p1P*p2p3*p3P*qp4)/D3D4 - 
                (64*GFV2*p1P*p2p3*p3P*qp4)/D3D4 + 
                (64*GFA2*p1p3*p2P*p4P*qp4)/D42 + 
                (128*GFAGFV*p1p3*p2P*p4P*qp4)/D42 + 
                (64*GFV2*p1p3*p2P*p4P*qp4)/D42 + 
                (64*GFA2*p1P*p2p3*p4P*qp4)/D42 - 
                (128*GFAGFV*p1P*p2p3*p4P*qp4)/D42 + 
                (64*GFV2*p1P*p2p3*p4P*qp4)/D42 + 
                (64*GFA2*p1p3*p2P*qP*qp4)/D3D4 + 
                (64*GFV2*p1p3*p2P*qP*qp4)/D3D4 + 
                (64*GFA2*p1P*p2p3*qP*qp4)/D3D4 + 
                (64*GFV2*p1P*p2p3*qP*qp4)/D3D4 - 
                (64*GFA2*p1p2*p3P*qP*qp4)/D3D4 - 
                (64*GFV2*p1p2*p3P*qP*qp4)/D3D4 + 
                (32*GFA2*M2*p2p3*qp1*qp4)/D42 + 
                (32*GFA2*M2*p2p3*qp1*qp4)/D3D4 - 
                (64*GFAGFV*M2*p2p3*qp1*qp4)/D42 + 
                (64*GFAGFV*M2*p2p3*qp1*qp4)/D3D4 + 
                (32*GFV2*M2*p2p3*qp1*qp4)/D42 + 
                (32*GFV2*M2*p2p3*qp1*qp4)/D3D4 + 
                (64*GFA2*p2P*p3P*qp1*qp4)/D3D4 + 
                (128*GFAGFV*p2P*p3P*qp1*qp4)/D3D4 + 
                (64*GFV2*p2P*p3P*qp1*qp4)/D3D4 + 
                (32*GFA2*M2*p1p3*qp2*qp4)/D42 + 
                (32*GFA2*M2*p1p3*qp2*qp4)/D3D4 + 
                (64*GFAGFV*M2*p1p3*qp2*qp4)/D42 - 
                (64*GFAGFV*M2*p1p3*qp2*qp4)/D3D4 + 
                (32*GFV2*M2*p1p3*qp2*qp4)/D42 + 
                (32*GFV2*M2*p1p3*qp2*qp4)/D3D4 + 
                (64*GFA2*p1P*p3P*qp2*qp4)/D3D4 - 
                (128*GFAGFV*p1P*p3P*qp2*qp4)/D3D4 + 
                (64*GFV2*p1P*p3P*qp2*qp4)/D3D4 - 
                (64*GFA2*M2*p1p2*qp3*qp4)/D3D4 - 
                (64*GFV2*M2*p1p2*qp3*qp4)/D3D4 - 
                (128*GFA2*p1P*p2P*qp3*qp4)/D3D4 - 
                (128*GFV2*p1P*p2P*qp3*qp4)/D3D4);

    return result;
}



double SquaredMatrixElementL(double GFV, double GFA){

    double GFA2, GFV2, GFAGFV, result;
    
    GFA2 = GFA*GFA;
    GFV2 = GFV*GFV;
    GFAGFV = GFA*GFV;
    
    result = 4*((-64*GFA2*m3*m3*m3*m4*p1p2)/D32 + 
                (64*GFV2*m3*m3*m3*m4*p1p2)/D32 - 
                (64*GFA2*m3*m4*m4*m4*p1p2)/D42 + 
                (64*GFV2*m3*m4*m4*m4*p1p2)/D42 - 
                (64*GFA2*m3*m3*p1p4*p2p3)/D32 - 
                (128*GFAGFV*m3*m3*p1p4*p2p3)/D32 - 
                (64*GFV2*m3*m3*p1p4*p2p3)/D32 - 
                (64*GFA2*m4*m4*p1p4*p2p3)/D42 - 
                (128*GFAGFV*m4*m4*p1p4*p2p3)/D42 - 
                (64*GFV2*m4*m4*p1p4*p2p3)/D42 - 
                (64*GFA2*m3*m3*p1p3*p2p4)/D32 + 
                (128*GFAGFV*m3*m3*p1p3*p2p4)/D32 - 
                (64*GFV2*m3*m3*p1p3*p2p4)/D32 - 
                (64*GFA2*m4*m4*p1p3*p2p4)/D42 + 
                (128*GFAGFV*m4*m4*p1p3*p2p4)/D42 - 
                (64*GFV2*m4*m4*p1p3*p2p4)/D42 - 
                (128*GFA2*m3*m4*p1p2*p3p4)/D3D4 + 
                (128*GFV2*m3*m4*p1p2*p3p4)/D3D4 - 
                (128*GFA2*p1p4*p2p3*p3p4)/D3D4 - 
                (256*GFAGFV*p1p4*p2p3*p3p4)/D3D4 - 
                (128*GFV2*p1p4*p2p3*p3p4)/D3D4 - 
                (128*GFA2*p1p3*p2p4*p3p4)/D3D4 + 
                (256*GFAGFV*p1p3*p2p4*p3p4)/D3D4 - 
                (128*GFV2*p1p3*p2p4*p3p4)/D3D4 + 
                (64*GFA2*m3*m4*p1p2*q2)/D32 + 
                (64*GFA2*m3*m4*p1p2*q2)/D42 - 
                (64*GFA2*m3*m4*p1p2*q2)/D3D4 - 
                (64*GFV2*m3*m4*p1p2*q2)/D32 - 
                (64*GFV2*m3*m4*p1p2*q2)/D42 + 
                (64*GFV2*m3*m4*p1p2*q2)/D3D4 + 
                (32*GFA2*p1p4*p2p3*q2)/D32 + 
                (32*GFA2*p1p4*p2p3*q2)/D42 + 
                (64*GFAGFV*p1p4*p2p3*q2)/D32 + 
                (64*GFAGFV*p1p4*p2p3*q2)/D42 - 
                (128*GFAGFV*p1p4*p2p3*q2)/D3D4 + 
                (32*GFV2*p1p4*p2p3*q2)/D32 + 
                (32*GFV2*p1p4*p2p3*q2)/D42 + 
                (32*GFA2*p1p3*p2p4*q2)/D32 + 
                (32*GFA2*p1p3*p2p4*q2)/D42 - 
                (64*GFAGFV*p1p3*p2p4*q2)/D32 - 
                (64*GFAGFV*p1p3*p2p4*q2)/D42 + 
                (128*GFAGFV*p1p3*p2p4*q2)/D3D4 + 
                (32*GFV2*p1p3*p2p4*q2)/D32 + 
                (32*GFV2*p1p3*p2p4*q2)/D42 - 
                (64*GFA2*p1p2*p3p4*q2)/D3D4 - 
                (64*GFV2*p1p2*p3p4*q2)/D3D4 + 
                (64*GFA2*m4*m4*p2p3*qp1)/D42 + 
                (128*GFAGFV*m4*m4*p2p3*qp1)/D42 + 
                (64*GFV2*m4*m4*p2p3*qp1)/D42 + 
                (64*GFA2*m3*m3*p2p4*qp1)/D32 - 
                (128*GFAGFV*m3*m3*p2p4*qp1)/D32 + 
                (64*GFV2*m3*m3*p2p4*qp1)/D32 + 
                (64*GFA2*p2p3*p3p4*qp1)/D3D4 + 
                (128*GFAGFV*p2p3*p3p4*qp1)/D3D4 + 
                (64*GFV2*p2p3*p3p4*qp1)/D3D4 + 
                (64*GFA2*p2p4*p3p4*qp1)/D3D4 - 
                (128*GFAGFV*p2p4*p3p4*qp1)/D3D4 + 
                (64*GFV2*p2p4*p3p4*qp1)/D3D4 + 
                (64*GFA2*m4*m4*p1p3*qp2)/D42 - 
                (128*GFAGFV*m4*m4*p1p3*qp2)/D42 + 
                (64*GFV2*m4*m4*p1p3*qp2)/D42 + 
                (64*GFA2*m3*m3*p1p4*qp2)/D32 + 
                (128*GFAGFV*m3*m3*p1p4*qp2)/D32 + 
                (64*GFV2*m3*m3*p1p4*qp2)/D32 + 
                (64*GFA2*p1p3*p3p4*qp2)/D3D4 - 
                (128*GFAGFV*p1p3*p3p4*qp2)/D3D4 + 
                (64*GFV2*p1p3*p3p4*qp2)/D3D4 + 
                (64*GFA2*p1p4*p3p4*qp2)/D3D4 + 
                (128*GFAGFV*p1p4*p3p4*qp2)/D3D4 + 
                (64*GFV2*p1p4*p3p4*qp2)/D3D4 + 
                (128*GFA2*m3*m4*qp1*qp2)/D3D4 - 
                (128*GFV2*m3*m4*qp1*qp2)/D3D4 - 
                (64*GFA2*m3*m4*p1p2*qp3)/D32 + 
                (64*GFA2*m3*m4*p1p2*qp3)/D3D4 + 
                (64*GFV2*m3*m4*p1p2*qp3)/D32 - 
                (64*GFV2*m3*m4*p1p2*qp3)/D3D4 + 
                (64*GFA2*p1p4*p2p3*qp3)/D3D4 + 
                (128*GFAGFV*p1p4*p2p3*qp3)/D3D4 + 
                (64*GFV2*p1p4*p2p3*qp3)/D3D4 + 
                (64*GFA2*p1p3*p2p4*qp3)/D3D4 - 
                (128*GFAGFV*p1p3*p2p4*qp3)/D3D4 + 
                (64*GFV2*p1p3*p2p4*qp3)/D3D4 - 
                (128*GFA2*p1p4*p2p4*qp3)/D3D4 - 
                (128*GFV2*p1p4*p2p4*qp3)/D3D4 - 
                (64*GFA2*p2p4*qp1*qp3)/D32 + 
                (128*GFAGFV*p2p4*qp1*qp3)/D32 - 
                (64*GFV2*p2p4*qp1*qp3)/D32 - 
                (64*GFA2*p1p4*qp2*qp3)/D32 - 
                (128*GFAGFV*p1p4*qp2*qp3)/D32 - 
                (64*GFV2*p1p4*qp2*qp3)/D32 - 
                (64*GFA2*m3*m4*p1p2*qp4)/D42 + 
                (64*GFA2*m3*m4*p1p2*qp4)/D3D4 + 
                (64*GFV2*m3*m4*p1p2*qp4)/D42 - 
                (64*GFV2*m3*m4*p1p2*qp4)/D3D4 - 
                (128*GFA2*p1p3*p2p3*qp4)/D3D4 - 
                (128*GFV2*p1p3*p2p3*qp4)/D3D4 + 
                (64*GFA2*p1p4*p2p3*qp4)/D3D4 + 
                (128*GFAGFV*p1p4*p2p3*qp4)/D3D4 + 
                (64*GFV2*p1p4*p2p3*qp4)/D3D4 + 
                (64*GFA2*p1p3*p2p4*qp4)/D3D4 - 
                (128*GFAGFV*p1p3*p2p4*qp4)/D3D4 + 
                (64*GFV2*p1p3*p2p4*qp4)/D3D4 - 
                (64*GFA2*p2p3*qp1*qp4)/D42 - 
                (128*GFAGFV*p2p3*qp1*qp4)/D42 - 
                (64*GFV2*p2p3*qp1*qp4)/D42 - 
                (64*GFA2*p1p3*qp2*qp4)/D42 + 
                (128*GFAGFV*p1p3*qp2*qp4)/D42 - 
                (64*GFV2*p1p3*qp2*qp4)/D42);
    
    return result;}
    
    
    
double SquaredMatrixElementLanti(double GFV, double GFA){

    double GFA2, GFV2, GFAGFV, result;
    
    GFA2 = GFA*GFA;
    GFV2 = GFV*GFV;
    GFAGFV = GFA*GFV;
    
    result = 4*((-64*GFA2*m3*m3*m3*m4*p1p2)/D32 + 
                (64*GFV2*m3*m3*m3*m4*p1p2)/D32 - 
                (64*GFA2*m3*m4*m4*m4*p1p2)/D42 + 
                (64*GFV2*m3*m4*m4*m4*p1p2)/D42 - 
                (64*GFA2*m3*m3*p1p4*p2p3)/D32 - 
                (128*GFAGFV*m3*m3*p1p4*p2p3)/D32 - 
                (64*GFV2*m3*m3*p1p4*p2p3)/D32 - 
                (64*GFA2*m4*m4*p1p4*p2p3)/D42 - 
                (128*GFAGFV*m4*m4*p1p4*p2p3)/D42 - 
                (64*GFV2*m4*m4*p1p4*p2p3)/D42 - 
                (64*GFA2*m3*m3*p1p3*p2p4)/D32 + 
                (128*GFAGFV*m3*m3*p1p3*p2p4)/D32 - 
                (64*GFV2*m3*m3*p1p3*p2p4)/D32 - 
                (64*GFA2*m4*m4*p1p3*p2p4)/D42 + 
                (128*GFAGFV*m4*m4*p1p3*p2p4)/D42 - 
                (64*GFV2*m4*m4*p1p3*p2p4)/D42 - 
                (128*GFA2*m3*m4*p1p2*p3p4)/D3D4 + 
                (128*GFV2*m3*m4*p1p2*p3p4)/D3D4 - 
                (128*GFA2*p1p4*p2p3*p3p4)/D3D4 - 
                (256*GFAGFV*p1p4*p2p3*p3p4)/D3D4 - 
                (128*GFV2*p1p4*p2p3*p3p4)/D3D4 - 
                (128*GFA2*p1p3*p2p4*p3p4)/D3D4 + 
                (256*GFAGFV*p1p3*p2p4*p3p4)/D3D4 - 
                (128*GFV2*p1p3*p2p4*p3p4)/D3D4 + 
                (64*GFA2*m3*m4*p1p2*q2)/D32 + 
                (64*GFA2*m3*m4*p1p2*q2)/D42 - 
                (64*GFA2*m3*m4*p1p2*q2)/D3D4 - 
                (64*GFV2*m3*m4*p1p2*q2)/D32 - 
                (64*GFV2*m3*m4*p1p2*q2)/D42 + 
                (64*GFV2*m3*m4*p1p2*q2)/D3D4 + 
                (32*GFA2*p1p4*p2p3*q2)/D32 + 
                (32*GFA2*p1p4*p2p3*q2)/D42 + 
                (64*GFAGFV*p1p4*p2p3*q2)/D32 + 
                (64*GFAGFV*p1p4*p2p3*q2)/D42 - 
                (128*GFAGFV*p1p4*p2p3*q2)/D3D4 + 
                (32*GFV2*p1p4*p2p3*q2)/D32 + 
                (32*GFV2*p1p4*p2p3*q2)/D42 + 
                (32*GFA2*p1p3*p2p4*q2)/D32 + 
                (32*GFA2*p1p3*p2p4*q2)/D42 - 
                (64*GFAGFV*p1p3*p2p4*q2)/D32 - 
                (64*GFAGFV*p1p3*p2p4*q2)/D42 + 
                (128*GFAGFV*p1p3*p2p4*q2)/D3D4 + 
                (32*GFV2*p1p3*p2p4*q2)/D32 + 
                (32*GFV2*p1p3*p2p4*q2)/D42 - 
                (64*GFA2*p1p2*p3p4*q2)/D3D4 - 
                (64*GFV2*p1p2*p3p4*q2)/D3D4 + 
                (64*GFA2*m4*m4*p2p3*qp1)/D42 + 
                (128*GFAGFV*m4*m4*p2p3*qp1)/D42 + 
                (64*GFV2*m4*m4*p2p3*qp1)/D42 + 
                (64*GFA2*m3*m3*p2p4*qp1)/D32 - 
                (128*GFAGFV*m3*m3*p2p4*qp1)/D32 + 
                (64*GFV2*m3*m3*p2p4*qp1)/D32 + 
                (64*GFA2*p2p3*p3p4*qp1)/D3D4 + 
                (128*GFAGFV*p2p3*p3p4*qp1)/D3D4 + 
                (64*GFV2*p2p3*p3p4*qp1)/D3D4 + 
                (64*GFA2*p2p4*p3p4*qp1)/D3D4 - 
                (128*GFAGFV*p2p4*p3p4*qp1)/D3D4 + 
                (64*GFV2*p2p4*p3p4*qp1)/D3D4 + 
                (64*GFA2*m4*m4*p1p3*qp2)/D42 - 
                (128*GFAGFV*m4*m4*p1p3*qp2)/D42 + 
                (64*GFV2*m4*m4*p1p3*qp2)/D42 + 
                (64*GFA2*m3*m3*p1p4*qp2)/D32 + 
                (128*GFAGFV*m3*m3*p1p4*qp2)/D32 + 
                (64*GFV2*m3*m3*p1p4*qp2)/D32 + 
                (64*GFA2*p1p3*p3p4*qp2)/D3D4 - 
                (128*GFAGFV*p1p3*p3p4*qp2)/D3D4 + 
                (64*GFV2*p1p3*p3p4*qp2)/D3D4 + 
                (64*GFA2*p1p4*p3p4*qp2)/D3D4 + 
                (128*GFAGFV*p1p4*p3p4*qp2)/D3D4 + 
                (64*GFV2*p1p4*p3p4*qp2)/D3D4 + 
                (128*GFA2*m3*m4*qp1*qp2)/D3D4 - 
                (128*GFV2*m3*m4*qp1*qp2)/D3D4 - 
                (64*GFA2*m3*m4*p1p2*qp3)/D32 + 
                (64*GFA2*m3*m4*p1p2*qp3)/D3D4 + 
                (64*GFV2*m3*m4*p1p2*qp3)/D32 - 
                (64*GFV2*m3*m4*p1p2*qp3)/D3D4 + 
                (64*GFA2*p1p4*p2p3*qp3)/D3D4 + 
                (128*GFAGFV*p1p4*p2p3*qp3)/D3D4 + 
                (64*GFV2*p1p4*p2p3*qp3)/D3D4 + 
                (64*GFA2*p1p3*p2p4*qp3)/D3D4 - 
                (128*GFAGFV*p1p3*p2p4*qp3)/D3D4 + 
                (64*GFV2*p1p3*p2p4*qp3)/D3D4 - 
                (128*GFA2*p1p4*p2p4*qp3)/D3D4 - 
                (128*GFV2*p1p4*p2p4*qp3)/D3D4 - 
                (64*GFA2*p2p4*qp1*qp3)/D32 + 
                (128*GFAGFV*p2p4*qp1*qp3)/D32 - 
                (64*GFV2*p2p4*qp1*qp3)/D32 - 
                (64*GFA2*p1p4*qp2*qp3)/D32 - 
                (128*GFAGFV*p1p4*qp2*qp3)/D32 - 
                (64*GFV2*p1p4*qp2*qp3)/D32 - 
                (64*GFA2*m3*m4*p1p2*qp4)/D42 + 
                (64*GFA2*m3*m4*p1p2*qp4)/D3D4 + 
                (64*GFV2*m3*m4*p1p2*qp4)/D42 - 
                (64*GFV2*m3*m4*p1p2*qp4)/D3D4 - 
                (128*GFA2*p1p3*p2p3*qp4)/D3D4 - 
                (128*GFV2*p1p3*p2p3*qp4)/D3D4 + 
                (64*GFA2*p1p4*p2p3*qp4)/D3D4 + 
                (128*GFAGFV*p1p4*p2p3*qp4)/D3D4 + 
                (64*GFV2*p1p4*p2p3*qp4)/D3D4 + 
                (64*GFA2*p1p3*p2p4*qp4)/D3D4 - 
                (128*GFAGFV*p1p3*p2p4*qp4)/D3D4 + 
                (64*GFV2*p1p3*p2p4*qp4)/D3D4 - 
                (64*GFA2*p2p3*qp1*qp4)/D42 - 
                (128*GFAGFV*p2p3*qp1*qp4)/D42 - 
                (64*GFV2*p2p3*qp1*qp4)/D42 - 
                (64*GFA2*p1p3*qp2*qp4)/D42 + 
                (128*GFAGFV*p1p3*qp2*qp4)/D42 - 
                (64*GFV2*p1p3*qp2*qp4)/D42);
    
    return result;}
    
//*************************************************
// Compute cross section for fixed neutrino energy
//*************************************************


void ComputeCrossSection(){
    
    double varold, intold, sigma;
    double integral = 0.0;
    double var = 0.0;
    
    errorcounter=0;
    float progress = 0.0;
    int barWidth = 50;
    
    std::cout << " \n\n";
    
    for (int ii = 1; ii < 30000001; ii++){
      
      GenerateEvent();
      DetermineWeight();
      
      intold = integral;
      varold = var;
	    
      integral = (intold*(ii-1)+weight)/ii;
      var = ((varold+intold*intold)*(ii-1)+weight*weight)/ii-integral*integral;
      sigma = sqrt(var/ii);
      
      //progress bar
      if ( ii % 500000 == 0){
      progress = ii/30000000.0;
      std::cout << "computing cross section:  [";
      int pos = barWidth * progress;
      for (int i = 0; i < barWidth; ++i) {
        if (i < pos) std::cout << "=";
        else if (i == pos) std::cout << ">";
        else std::cout << " ";
      }
      std::cout << "]  " << int(progress * 100.0) << " %\r";
      std::cout.flush();
      }
      
    }

    crosssectionresult=integral;
    deltacrosssectionresult=sigma;
    
    if (errorcounter > 0){
    std::cout << " \n\n";
    std::cout << "Out of 30,000,000 weighted events, " << errorcounter << " events with unphysical kinematics were ignored \n\n";}
    
}
  
  
//**********************************
// Determine the weight of an event
//**********************************

void DetermineWeight(){
    
    if (zeroweight == 1){weight = 0.0;}
    else {
  
    // Set vector and axialvector couplings
    // note that the sign in the propagator corresponds to the unconventional metric of Lovseth, Radomski 
    
    if (model.compare("4F") == 0){
    GV = GVtot/2;  // factor 1/2 to agree with the normalization of the effective Hamiltonian of the paper
    GA = GAtot/2;} // factor 1/2 to agree with the normalization of the effective Hamiltonian of the paper
    else {  
    GV = GVSM - GP*GP*sqrt(2)/2/GF/(2*p1p2-MZP*MZP);
    GA = GASM;}
    
    // Jacobian factor (27) of Lovseth, Radomski, without the form factor 
    // (form factor is cancelled by the corresponding term in PLP)
    J = Twopi/8/eps1/M*D3/16/(-qp1)/sqrt(u4)*D4/8/qc/WC;
    
    // Define the squared matrix element
    if (anti == 0){PLP = SquaredMatrixElementPLP(GV, GA);}
    else {PLP = SquaredMatrixElementPLPanti(GV, GA);}
    
    Laa = 0.0;
    if (material.compare("proton") == 0 || material.compare("neutron") == 0){
    if (anti == 0){Laa = SquaredMatrixElementL(GV, GA);}
    else {Laa = SquaredMatrixElementLanti(GV, GA);}
    }
	      
    // Cross section (26) of Lovseth, Radomski
    if (material.compare("proton") == 0){
      deltaSigma=(GF*GF)*aem*aem*(Z*Z)*0.5/(2*pi*2*pi*2*pi*2*pi*2*pi*2*pi)/M/eps1*
      (4*PLP+4*M2*Laa*(1+q2/4/M2)*q2/4/M2*GMp(q2)*GMp(q2)/(GEp(q2)*GEp(q2)+q2/4/M2*GMp(q2)*GMp(q2)))/
      (q2*q2)*J*(0.389379e12)*Pauli(sqrt(q2*(1+q2/4/M2)));
    }
    else if (material.compare("neutron") == 0){
      deltaSigma=(GF*GF)*aem*aem*(Z*Z)*0.5/(2*pi*2*pi*2*pi*2*pi*2*pi*2*pi)/M/eps1*
      (4*PLP+4*M2*Laa*(1+q2/4/M2)*q2/4/M2*GMn(q2)*GMn(q2)/(GEn(q2)*GEn(q2)+q2/4/M2*GMn(q2)*GMn(q2)))/
      (q2*q2)*J*(0.389379e12)*Pauli(sqrt(q2*(1+q2/4/M2)));
    }
    else {
      deltaSigma=(GF*GF)*aem*aem*(Z*Z)*0.5/(2*pi*2*pi*2*pi*2*pi*2*pi*2*pi)/M/eps1*4*PLP/(q2*q2)*J*(0.389379e12);
    }
    
       
    // Define the weight of the event
    weight = deltaSigma*((u1max-u1min)*(u2max-u2min)*(u3max-u3min)*(u4max-u4min)*(u5max-u5min)*(u6max-u6min)*(u7max-u7min));}
    
    if (energy_type.compare("1") != 0){
      weight=weight*probability_list[bin]*length_probability_list;
      }
      
    if (flagkinematics == 1){
      weight = 0.0; errorcounter = errorcounter+1; 
    }
    
    if (is_nan(weight) == 1){
      weight = 0.0; errorcounter = errorcounter+1;
    }
   
    return;
}


//**********************************
// Determine the maximum weight
//**********************************

void FindMaxWeight(){
  
    maxweight = 0.0;
    averageweight = 0.0;
    
    float progress = 0.0;
    int barWidth = 50;

    std::cout << "\n\n";
    
    for(int n=1; n<30000001; n++){
      
      //progress bar
      if (n % 500000 == 0){
      progress = n/30000000.0;
      std::cout << "finding max weight:  [";
      int pos = barWidth * progress;
      for (int i = 0; i < barWidth; ++i) {
        if (i < pos) std::cout << "=";
        else if (i == pos) std::cout << ">";
        else std::cout << " ";
      }
      std::cout << "]  " << int(progress * 100.0) << " %\r";
      std::cout.flush();
      }
    
    GenerateEvent();
    DetermineWeight();
    
    averageweight = ((n-1)*averageweight+weight)/n;
    
    if (weight > maxweight){maxweight = weight;}}
          
    std::cout << "\n\n";
    std::cout << "To determine the maximum weight, 30,000,000 weighted events were computed \n\n";
    std::cout << "max_weight =  " << maxweight*2 << "\n";
    std::cout << "average_weight =  " << averageweight << "\n";
 
    return;
 
}

//*************************************************
// Read the file containing the neutrino flux distribution
//*************************************************

void ReadDistribution(){
    
    length_probability_list = distribution_list.size()/3;
    
    double Enumin;
    double Enumax;
    double probability;
    
    for(int n=0; n < length_probability_list; n++){
      
      Enumin=distribution_list[n*3];
      Enumax=distribution_list[n*3+1];
      probability=distribution_list[n*3+2];
      
      Enumin_list.push_back(Enumin);
      Enumax_list.push_back(Enumax);
      probability_list.push_back(probability);
      
    }
    
    return;
    
}

//*************************************************
// Load flux from a ROOT file
//*************************************************

void MakeFluxFromROOT(string filename, int target_pdg){
    
    TFile* infile = TFile::Open(filename.c_str());
    if (!infile || infile->IsZombie()) {
        std::cerr << "Error: Could not open ROOT file: " << filename << std::endl;
        return;
    }
    
    // Get the flux TTree
    TTree* flux_tree = (TTree*)infile->Get("flux");
    if (!flux_tree) {
        std::cerr << "Error: Could not find 'flux' TTree in ROOT file" << std::endl;
        infile->Close();
        return;
    }
    
    // Set up branch addresses
    Double_t wgt, E;
    Int_t pdg;
    Double_t vtxx, vtxy, vtxz;
    Double_t px, py, pz;
    
    flux_tree->SetBranchAddress("wgt", &wgt);
    flux_tree->SetBranchAddress("E", &E);
    flux_tree->SetBranchAddress("pdg", &pdg);
    flux_tree->SetBranchAddress("vtxx", &vtxx);
    flux_tree->SetBranchAddress("vtxy", &vtxy);
    flux_tree->SetBranchAddress("vtxz", &vtxz);
    flux_tree->SetBranchAddress("px", &px);
    flux_tree->SetBranchAddress("py", &py);
    flux_tree->SetBranchAddress("pz", &pz);
    
    // Find energy range and create histogram
    Long64_t nentries = flux_tree->GetEntries();
    std::cout << "Found " << nentries << " entries in flux tree" << std::endl;
    
    double min_E = 1e9;
    double max_E = 0.0;
    
    // First pass: find energy range for matching PDG
    for (Long64_t i = 0; i < nentries; i++) {
        flux_tree->GetEntry(i);
        if (pdg == target_pdg) {
            if (E < min_E) min_E = E;
            if (E > max_E) max_E = E;
        }
    }
    
    if (max_E <= min_E) {
        std::cerr << "Error: No entries found for PDG code " << target_pdg << std::endl;
        infile->Close();
        return;
    }
    
    std::cout << "Energy range: " << min_E << " to " << max_E << " GeV" << std::endl;
    
    // Create histogram with appropriate binning
    int nbins = 100;
    TH1D* flux_hist = new TH1D("flux_hist", "Neutrino Flux", nbins, min_E, max_E);
    
    // Second pass: fill histogram with weights for matching PDG
    for (Long64_t i = 0; i < nentries; i++) {
        flux_tree->GetEntry(i);
        if (pdg == target_pdg) {
            flux_hist->Fill(E, wgt);
        }
    }
    
    // Convert histogram to flux distribution format
    distribution_list.clear();
    Enumin_list.clear();
    Enumax_list.clear();
    probability_list.clear();
    
    double total_content = 0.0;
    
    // Calculate total content for normalization
    for (int i = 1; i <= nbins; i++) {
        total_content += flux_hist->GetBinContent(i);
    }
    
    if (total_content <= 0) {
        std::cerr << "Error: Histogram has no positive content for PDG " << target_pdg << std::endl;
        delete flux_hist;
        infile->Close();
        return;
    }
    
    // Fill distribution list
    for (int i = 1; i <= nbins; i++) {
        double emin = flux_hist->GetBinLowEdge(i);
        double emax = flux_hist->GetBinLowEdge(i) + flux_hist->GetBinWidth(i);
        double content = flux_hist->GetBinContent(i);
        double probability = content / total_content;
        
        if (probability > 0) {  // Only add bins with non-zero probability
            distribution_list.push_back(emin);
            distribution_list.push_back(emax);
            distribution_list.push_back(probability);
        }
    }
    
    delete flux_hist;
    infile->Close();
    
    std::cout << "Successfully loaded flux from ROOT file for PDG " << target_pdg << std::endl;
    std::cout << "Created distribution with " << distribution_list.size()/3 << " energy bins\n" << std::endl;
    
    // Now read the distribution as usual
    ReadDistribution();
    
    return;
    
}

void LoadFluxFromROOT(string filename, int target_pdg){
    
    TFile* infile = TFile::Open(filename.c_str());
    if (!infile || infile->IsZombie()) {
        std::cerr << "Error: Could not open ROOT file: " << filename << std::endl;
        return;
    }

    // Turn PDG code into name string to grab the right histogram
    string pdg_name;
    if (abs(target_pdg) == 12) pdg_name = "nue";
    else if (abs(target_pdg) == 14) pdg_name = "numu";
    else if (abs(target_pdg) == 16) pdg_name = "nutau";
    else {
        std::cerr << "Error: Unsupported PDG code " << target_pdg << std::endl;
        infile->Close();
        return;
    }
    if (target_pdg < 0) pdg_name = pdg_name+"bar";

    // Get the histogram
    TH1D* flux_hist = (TH1D*)infile->Get(("hE"+pdg_name+"_cv").c_str());
    if (!flux_hist) {
        std::cerr << "Error: Could not find histogram hE" << pdg_name << " in ROOT file" << std::endl;
        infile->Close();
        return;
    }

    // Convert histogram to flux distribution format
    distribution_list.clear();
    Enumin_list.clear();
    Enumax_list.clear();
    probability_list.clear();

    double total_content = 0.0;
    int nbins = flux_hist->GetNbinsX();

    // Calculate total content for normalization
    for (int i = 1; i <= nbins; i++) {
        total_content += flux_hist->GetBinContent(i);
    }
    if (total_content <= 0) {
        std::cerr << "Error: Histogram has no positive content for PDG " << target_pdg << std::endl;
        infile->Close();
        return;
    }

    // Fill distribution list
    for (int i = 1; i <= nbins; i++) {
        double emin = flux_hist->GetBinLowEdge(i);
        double emax = flux_hist->GetBinLowEdge(i) + flux_hist->GetBinWidth(i);
        double content = flux_hist->GetBinContent(i);
        double probability = content / total_content;
        if (probability > 0) {  // Only add bins with non-zero probability
            distribution_list.push_back(emin);
            distribution_list.push_back(emax);
            distribution_list.push_back(probability);
        }
    }
    infile->Close();

    std::cout << "Successfully loaded flux from ROOT file for PDG " << target_pdg << std::endl;
    std::cout << "Created distribution with " << distribution_list.size()/3 << " energy bins\n" << std::endl;

    // Now read the distribution as usual
    ReadDistribution();

    return;

}
//*************************************************
// Write file with the generated events
//*************************************************

void WriteEventFile(string filename){
  
    ofstream outfile;
    outfile.open(filename.c_str(), ios_base::trunc | ios_base::out | ios_base::in);
    
    // write the header
    outfile << "This is an event file created by TEG version 1.0 \n\n\n";
    outfile << "The format of the events is similar to that of MadGraph \n\n";
    outfile << "======================================== \n";
    outfile << "PDG code, in/out state, px, py, pz, E, m \n"; 
    outfile << "======================================== \n\n";   
    outfile << "PDG codes are       11 for a electron \n";
    outfile << "                   -11 for a positron \n";
    outfile << "                    12 for a electron neutrino \n";
    outfile << "                   -12 for a electron anti-neutrino \n";
    outfile << "                    13 for a muon \n";
    outfile << "                   -13 for a anti-muon \n";
    outfile << "                    14 for a muon neutrino \n";
    outfile << "                   -14 for a muon anti-neutrino \n";
    outfile << "                    15 for a tau \n";
    outfile << "                   -15 for a anti-tau \n";
    outfile << "                    16 for a tau neutrino \n";
    outfile << "                   -16 for a tau anti-neutrino \n";
    outfile << "                  2212 for a proton \n";
    outfile << "                  2112 for a neutron \n\n";
    outfile << "in/out state is    -1 for a particle in the initial state \n";
    outfile << "                    1 for a particle in the final state \n\n";
    outfile << "px is the particle momentum in x direction \n";
    outfile << "py is the particle momentum in y direction \n";
    outfile << "pz is the particle momentum in z direction (= beam direction) \n";
    outfile << "E is the particle Energy \n";
    outfile << "m is the particle mass \n\n";
    outfile << "(momenta, energies and masses are all in GeV) \n\n\n";
    
    int n = 0;

    while(n < 20*Nevents){

            outfile << "\n<event>\n";
            outfile << PDG1 << " -1 ";
            for(int d=1;d<4;d++){
                outfile << std::fixed << std::setprecision(8) << ::data[n+d] << " ";
            }
            outfile << std::fixed << std::setprecision(8) << ::data[n] << " ";
            outfile << std::fixed << std::setprecision(8) << "0.0\n";
            n += 4;
            
            outfile << PDG2 << "  1 ";
            for(int d=1;d<4;d++){
                outfile << std::fixed << std::setprecision(8) << ::data[n+d] << " ";
            }
            outfile << std::fixed << std::setprecision(8) << ::data[n] << " ";
            outfile << std::fixed << std::setprecision(8) << "0.0\n";
            n += 4;
            
            outfile << PDG4 << "  1 ";
            for(int d=1;d<4;d++){
                outfile << std::fixed << std::setprecision(8) << ::data[n+d] << " ";
            }
            outfile << std::fixed << std::setprecision(8) << ::data[n] << " ";
            outfile << std::fixed << std::setprecision(8) << m4 << "\n";
            n += 4;
            
            outfile << PDG3 << "  1 ";
            for(int d=1;d<4;d++){
                outfile << std::fixed << std::setprecision(8) << ::data[n+d] << " ";
            }
            outfile << std::fixed << std::setprecision(8) << ::data[n] << " ";
            outfile << std::fixed << std::setprecision(8) << m3 << "\n";
	    
	    if (material.compare("proton") == 0){
            n += 4;}
	    else if (material.compare("neutron") == 0){
	    n += 4;}
	    else {
	    n += 8;}
	    	    
	    if (material.compare("proton") == 0){
	    outfile << 2212 << "  1 ";
            for(int d=1;d<4;d++){
                outfile << std::fixed << std::setprecision(8) << ::data[n+d] << " ";
            }
            outfile << std::fixed << std::setprecision(8) << ::data[n] << " ";
            outfile << std::fixed << std::setprecision(8) << M << "\n";
            n += 4;}
            
        else if (material.compare("neutron") == 0){
	    outfile << 2112 << "  1 ";
            for(int d=1;d<4;d++){
                outfile << std::fixed << std::setprecision(8) << ::data[n+d] << " ";
            }
            outfile << std::fixed << std::setprecision(8) << ::data[n] << " ";
            outfile << std::fixed << std::setprecision(8) << M << "\n";
            n += 4;}
            
	    outfile << "</event>";
    }

    outfile.close();
}

bool exists_test (const std::string& name) {
    if (FILE *file = fopen(name.c_str(), "r")) {
        fclose(file);
        return true;
    } else {
        return false;
    }   
}

void WriteXsecTempFile(string filename){
  
    ofstream outfile;
    if(exists_test(filename)){
        std::cout << "Appending to existing cross section temporary file \n";
        outfile.open(filename, std::ios_base::app); // append instead of overwrite     
    }
    else {
        outfile.open(filename.c_str(), ios_base::trunc | ios_base::out | ios_base::in);
        outfile << "# This is a temporary file created by TEG version 2.0 \n";
        outfile << "# It contains the computed cross section for given neutrino energy \n\n";
        outfile << "# It contains the computed cross section for given neutrino energy \n\n";
        outfile << "# Neutrino energy (GeV)    Cross section (fb)    Uncertainty (fb) \n\n";
    }
    // else {
    //     std::cout << "Appending to existing cross section temporary file \n";
    //     outfile.seekp(0, ios::end);
    // }
    outfile << std::fixed << std::setprecision(6) << Enu << "    ";
    outfile << std::scientific << std::setprecision(6) << crosssectionresult << "    ";
    outfile << std::scientific << std::setprecision(6) << deltacrosssectionresult << "\n";
    outfile.close();
}


//*************************************************
// Generate unweighted events
//*************************************************
   
void GenerateEvents(){
      
      double random;
      int i = 0;
      
      errorcounter=0;
      eventcounter=0;
      reweightcounter=0; 
      
      float progress = 0.0;
      int barWidth = 50;
      
      std::cout << "\n\n";
      
      while(i<Nevents){
		
      //progress bar
      if (eventcounter % 500000 == 0){
      progress = (i + 0.1)/Nevents;
      std::cout << "generating events:  [";
      int pos = barWidth * progress;
      for (int j = 0; j < barWidth; ++j) {
        if (j < pos) std::cout << "=";
        else if (j == pos) std::cout << ">";
        else std::cout << " ";
      }
      std::cout << "]  " << int(progress * 100.0) << " %\r";
      std::cout.flush();
      }

      eventcounter=eventcounter+1;

      GenerateEvent();
      DetermineWeight();
      
      if(weight>2*maxweight){
	 reweightcounter=reweightcounter+1;
//	 std::cout << "\n\n";
//	 std::cout << "Warning: weight of an event is larger than the maximum weight \n";
//	 std::cout << "weight / maxweight = " << weight/2/maxweight << "\n\n";
      }
      
      random = realdistribution(generator);
      
      if(random < weight/maxweight/2.0){
	
        ::data[20*i] = event[0][0];
        ::data[20*i+1] = event[0][1];
        ::data[20*i+2] = event[0][2];
        ::data[20*i+3] = event[0][3];
        ::data[20*i+4] = event[1][0];
        ::data[20*i+5] = event[1][1];
        ::data[20*i+6] = event[1][2];
        ::data[20*i+7] = event[1][3];
        ::data[20*i+8] = event[2][0];
        ::data[20*i+9] = event[2][1];
        ::data[20*i+10] = event[2][2];
        ::data[20*i+11] = event[2][3];
        ::data[20*i+12] = event[3][0];
        ::data[20*i+13] = event[3][1];
        ::data[20*i+14] = event[3][2];
        ::data[20*i+15] = event[3][3];
        ::data[20*i+16] = event[4][0];
        ::data[20*i+17] = event[4][1];
        ::data[20*i+18] = event[4][2];
        ::data[20*i+19] = event[4][3];
	
	i++;}}
    
    std::cout << "\n\n";
    std::cout << "To generate the " << Nevents << " events, " << eventcounter << " weighted events were computed \n\n";
    
    if (errorcounter > 0){
    std::cout << "Out of the " << eventcounter << " weighted events, " << errorcounter << " events with unphysical kinematics were ignored \n\n";}
    
    if (reweightcounter > 0){
    std::cout << "Out of the " << eventcounter << " weighted events, " << reweightcounter << " events had weights larger than the maximum weight determined earlier \n\n";}
	
    return;

}